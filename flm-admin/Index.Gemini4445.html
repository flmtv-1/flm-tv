<!DOCTYPE html>
<!-- THIS IS THE START OF THE COMPLETE INDEX.HTML FILE -->

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>FLM TV</title>
<link href="./assets/logos/your-logo-file.png" rel="icon" type="image/png"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet"/>
<!-- Tailwind CSS CDN - Added for the new video player's styling -->
<script src="https://cdn.tailwindcss.com"></script>
<style>
        /* CSS Reset & Variables */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #e50914; /* Netflix Red */
            --primary-dark: #b8070f;
            --bg: #141414; /* Dark background */
            --bg-light: #1f1f1f;
            --text: #ffffff;
            --text-gray: #b3b3b3;
            --card-bg: #282828;
            --border-color: #333;
            --font-family-sans: 'Inter', sans-serif;
            /* Dynamic variable for button/accent color */
            --dynamic-btn-color: #e50914; /* Default to primary red */
        }

        /* Style for the member Sign Up Link */
        #memberSignUpLink {
            background-color: var(--primary); /* Netflix Red */
            color: var(--text); /* White text */
            padding: 8px 15px;
            border-radius: 5px;
            text-decoration: none; /* Removes underline from the link */
            display: inline-block; /* Allows padding and background to apply correctly */
            transition: background-color 0.3s ease; /* Smooth hover effect */
            font-weight: 600; /* Make text a bit bolder */
            margin-left: 15px; /* Adds space from other nav items if needed */
        }

        #memberSignUpLink:hover {
            background-color: var(--primary-dark); /* Darker red on hover */
        }

        /* Adjust padding for other nav items if needed, to align them */
        nav ul li a {
            padding: 6px 15px; /* Adjusted for consistent spacing */
        }
        /* Header CHAT Button - REMOVED from header as per user request */
        /* .header-chat-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 6px 15px;
            margin-left: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.2s ease, transform 0.1s ease;
            white-space: nowrap;
            flex-shrink: 0;
            align-self: center;
        }

        .header-chat-btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        } */
        .header-chat-icon {
            font-size: 1.5em; /* Adjust size as needed */
            color: var(--text);
            margin-left: 20px; /* Adjust spacing from navigation items */
            cursor: pointer;
            transition: color 0.3s ease;
        }
        .header-chat-icon:hover {
            color: var(--primary); /* Hover effect */

        }

        /* Ensure HTML and Body take full height for layout */
        html {
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        body {
            min-height: 100vh; /* Ensure body fills viewport if content is short */
            font-family: var(--font-family-sans);
            background-color: var(--bg);
            color: var(--text);
            line-height: 1.6;
            /* overflow-y will be controlled by JS for body */
        }

        /* Utility Classes */
        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px 0;
        }

        .flex-row {
            display: flex;
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .text-center {
            text-align: center;
        }

        .py-4 {
            padding-top: 1rem;
            padding-bottom: 1rem;
        }

        .my-8 {
            margin-top: 2rem;
            margin-bottom: 2rem;
        }

        /* Header/Navigation */
        header {
            background-color: var(--bg-light);
            padding: 5px 0; /* Adjusted padding to make it thinner */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        header .logo {
            color: var(--primary);
            font-size: 1.5em; /* Adjusted font size */
            font-weight: 700;
            text-decoration: none;
            margin-left: 20px;
            display: flex; /* Make logo a flex container to align image and text */
            align-items: center; /* Vertically align items */
            gap: 10px; /* Space between logo image and text */
        }
        header .logo img { /* Style for the image logo */
            height: 40px; /* Adjusted logo height */
            vertical-align: middle;
        }
        /* Ensure FLM TV text stays on one line */
        header .logo span {
            white-space: nowrap;
        }


        nav ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
        }

        nav ul li {
            margin-right: 20px;
        }

        nav ul li a {
            color: var(--text-gray);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        nav ul li a:hover,
        nav ul li a.active {
            color: var(--primary);
        }

        /* Hero Slideshow Section */
        .hero-slideshow {
            position: relative;
            width: 100%;
            height: 500px; /* Or a flexible height like 70vh */
            overflow: hidden;
            margin-bottom: 0px; /* Adjusted to remove space */
            background-color: var(--bg-dark); /* Fallback */
        }

        .hero-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            display: flex;
            align-items: center;
            padding: 0 5%;
            color: var(--text);
            box-sizing: border-box;
            /* Gradient Overlay for text visibility */
            background-image: linear-gradient(to right, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 40%, rgba(0,0,0,0) 100%), var(--image-url);
        }

        .hero-slide.active {
            opacity: 1;
            z-index: 1;
        }
        .hero-slide.active::before { /* For dynamic image */
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: var(--image-url);
            background-size: cover;
            background-position: center;
            z-index: -1;
        }
        .hero-slide.active::after { /* Darker overlay for text */
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 40%, rgba(0,0,0,0) 100%);
            z-index: 0;
        }


        .hero-content-wrapper {
            position: relative;
            z-index: 2; /* Above the gradient overlay */
            max-width: 600px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        .hero-content-wrapper h1 {
            font-size: 3.5em;
            margin-bottom: 15px;
        }

        .hero-content-wrapper p {
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .btn {
            display: inline-block;
            background-color: var(--primary);
            color: var(--text);
            padding: 12px 25px;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 600;
            border: none;
            cursor: pointer;
        }

        .btn:hover {
            background-color: var(--primary-dark);
        }

        /* Search Bar */
        .search-bar-container {
            padding: 10px 0;
            background-color: var(--bg-light);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            text-align: center;
            margin-bottom: 0px; /* Adjusted to remove space */
        }
        #movieSearchInput {
            width: 80%;
            max-width: 600px;
            padding: 12px 20px;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--text);
            border-radius: 25px;
            font-size: 1.1em;
            outline: none;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #movieSearchInput:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(229, 9, 20, 0.3);
        }


        /* Section Titles */
        .section-title {
            font-size: 2em;
            color: var(--text);
            margin-bottom: 25px;
            border-left: 5px solid var(--primary);
            padding-left: 10px;
        }

        /* Movie/Card Grid */
        .movie-grid, .channel-grid, .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .movie-card, .channel-card, .category-card {
            background-color: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            position: relative;
        }

        .movie-card:hover, .channel-card:hover, .category-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        /* Movie card image/video (longer) */
        .movie-card img, .movie-card video.trailer-preview {
            width: 100%;
            height: 270px; /* Longer height for movie cards */
            object-fit: cover;
            display: block;
            transition: opacity 0.3s ease;
        }
        .movie-card video.trailer-preview {
            display: none; /* Hidden by default */
        }

        /* Channel card image (shorter) */
        .channel-card img {
            width: 100%;
            height: 150px; /* Shorter height for channel cards */
            object-fit: cover;
            display: block;
            transition: opacity 0.3s ease;
        }


        .movie-card-content, .channel-card-content {
            padding: 15px;
            color: var(--text);
        }

        .movie-card-content h3, .channel-card-content h3 {
            font-size: 1.1em;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .movie-card-content p, .channel-card-content p {
            font-size: 0.9em;
            color: var(--text-gray);
        }

        .coming-soon {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: bold;
        }

        /* Category card (shorter) */
        .category-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 120px; /* Shorter height for category cards */
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }

        .category-card:hover {
            background-color: var(--primary-dark);
        }

        .category-card i {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .category-card h3 {
            font-size: 1.1em;
            color: var(--text);
        }

        /* Footer */
        footer {
            background-color: var(--bg-light);
            color: var(--text-gray);
            padding: 30px 0;
            text-align: center;
            font-size: 0.9em;
            margin-top: 40px;
        }

        footer p {
            margin-bottom: 10px;
        }

        footer .social-links a {
            color: var(--text-gray);
            font-size: 1.5em;
            margin: 0 10px;
            transition: color 0.3s ease;
        }

        footer .social-links a:hover {
            color: var(--primary);
        }

        /* Floating Chat Button (main page) */
        .chat-toggle-button-floating {
          position: fixed;
          bottom: 20px;
          right: 20px; /* Positioned to the right */
          left: auto; /* Override left: 50% */
          transform: none; /* Override translateX(-50%) */
          background-color: var(--primary);
          color: white;
          border: none;
          border-radius: 50%;
          width: 55px;
          height: 55px;
          font-size: 1.8em;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          box-shadow: 0 4px 10px rgba(0,0,0,0.3);
          z-index: 10002;
          transition: background-color 0.3s ease, opacity 0.3s ease, pointer-events 0.3s ease;
          opacity: 0; /* Hidden by default, controlled by JS */
          pointer-events: none; /* No interaction when hidden */
        }
        .chat-toggle-button-floating:hover {
          background-color: var(--primary-dark);
        }

        /* Floating AI Button (main page) */
        .luma-toggle-button-floating {
            position: fixed;
            bottom: 20px;
            right: 90px; /* Positioned to the left of the chat toggle button (20px + 55px button width + 15px gap) */
            left: auto; /* Override left: 50% */
            transform: none; /* Override translateX(-50%) */
            background-color: #4CAF50; /* Green for AI */
            color: white;
            border: none;
            border-radius: 50%;
            width: 55px;
            height: 55px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 10002; /* Same as chat toggle */
            transition: background-color 0.3s ease, opacity 0.3s ease, pointer-events 0.3s ease;
            opacity: 0; /* Hidden by default */
            pointer-events: none; /* No interaction when hidden */
        }
        .luma-toggle-button-floating:hover {
            background-color: #45a049;
        }
        /* Style for the AI button image icon */
        .luma-toggle-button-floating img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }


        /* Chat Box - Always Right-Aligned and Tall */
        #chatBox {
          display: none; /* Hidden by default */
          position: fixed;
          right: 0; /* Position on the right side */
          bottom: 0; /* Aligned with the bottom */
          top: 0; /* Stretches to the top, creating a tall box */
          width: 380px; /* Adjusted width to be wider */
          height: 100%; /* Height determined by top/bottom positioning */
          background-color: #1a1a1a;
          color: white;
          border-radius: 0px; /* No rounded corners for full height */
          box-shadow: 0 0 12px rgba(0,0,0,0.6);
          z-index: 10003;
          overflow: hidden;
          transition: all 0.3s ease-in-out; /* Smooth transition for appearance */
        }

        #chatBox iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* AI Panel (Zaina J.) */
        #lumaPanel {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 0; /* Position at the bottom */
            top: 0; /* Stretch from top to bottom */
            right: 0; /* Default right position, flush with edge */
            width: 380px; /* Same width as chatbox */
            height: 100%; /* Ensure it fills full height */
            background-color: #1a1a1a; /* Changed to solid color matching chatbox */
            color: white;
            /* Padding moved to inner-content div */
            box-shadow: 0 0 12px rgba(0,0,0,0.6);
            z-index: 10003; /* Same z-index as chatbox */
            overflow-y: auto;
            border-radius: 0px; /* No rounded corners for full height */
            transition: all 0.3s ease-in-out;
            display: flex; /* Use flexbox for internal layout */
            flex-direction: column; /* Stack content vertically */
        }
        /* Inner div for padding within lumaPanel */
        #lumaPanel .luma-panel-content {
            padding: 20px;
            flex-grow: 1; /* Allow content to grow and fill space */
            display: flex;
            flex-direction: column;
        }
        #lumaPanel .luma-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        #lumaPanel .luma-header img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
            border: 2px solid var(--primary);
        }
        #lumaPanel .luma-header h2 {
            font-size: 1.5em;
            color: var(--primary);
            margin: 0; /* Reset margin */
        }
        #lumaPanel p {
            margin-bottom: 15px;
            color: var(--text-gray);
        }
        #lumaPanel input {
            width: 100%;
            padding: 10px;
            border: 1px solid #444;
            background-color: #333;
            color: white;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        #lumaPanel button {
            background-color: #4CAF50; /* Green for AI */
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #lumaPanel button:hover {
            background-color: #45a049;
        }
        #lumaPanel .close-panel-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            color: var(--text-gray);
            cursor: pointer;
            z-index: 1; /* Ensure it's above other content */
        }
        #lumaPanel .close-panel-btn:hover {
            color: var(--primary);
        }

        /* Parent Control Button */
        .parent-control-button {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: var(--card-bg);
            color: var(--text-gray);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 55px;
            height: 55px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 9997;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .parent-control-button:hover {
            background-color: var(--bg-light);
            color: var(--primary);
        }

        /* Parent Control Modal */
        #parentControlModal, #memberAuthModal, #castDetailModal { /* Added castDetailModal here */
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            z-index: 10001;
            justify-content: center;
            align-items: center;
        }

        .parent-control-content, .member-auth-content {
            background-color: var(--bg-light);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            width: 90%;
            max-width: 500px;
            color: var(--text);
            position: relative;
        }

        .parent-control-content h2, .member-auth-content h2 {
            margin-bottom: 20px;
            color: var(--primary);
            text-align: center;
        }

        .parent-control-content label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        /* Specific style for parent control password inputs to ensure text visibility */
        .parent-control-content input[type="password"],
        .parent-control-content input[type="text"] { /* Also apply to text inputs like security question */
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: black; /* Force black text */
            border-radius: 5px;
            font-size: 1em;
        }

        .member-auth-content input[type="email"],
        .member-auth-content input[type="password"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--text); /* Keep white text for general auth inputs */
            border-radius: 5px;
            font-size: 1em;
        }

        .member-auth-content .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .member-auth-content .btn-group .btn {
            flex-grow: 1;
        }
        .member-auth-content #upgradePremiumBtn {
            background-color: #4CAF50; /* Green for upgrade */
            display: none; /* Hidden by default */
        }
        .member-auth-content #upgradePremiumBtn:hover {
            background-color: #45a049;
        }


        .parent-control-content .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .parent-control-content .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .parent-control-content .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .parent-control-content .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        .parent-control-content input:checked + .slider {
            background-color: var(--primary);
        }

        .parent-control-content input:focus + .slider {
            box-shadow: 0 0 1px var(--primary);
        }

        .parent-control-content input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }

        .parent-control-content .close-parent-modal,
        .member-auth-content .close-auth-modal {
            position: absolute;
            top: 15px;
            right: 25px;
            color: var(--text-gray);
            font-size: 2em;
            cursor: pointer;
        }

        /* Favorite icon on movie cards */
        .movie-card .favorite-icon {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #b3b3b3; /* Default grey */
            font-size: 1.8em;
            cursor: pointer;
            text-shadow: 0 0 5px rgba(0,0,0,0.7);
            transition: color 0.2s ease;
            z-index: 5; /* Above image */
        }

        .movie-card .favorite-icon.favorited {
            color: var(--primary); /* Red when favorited */
        }
        .movie-card .favorite-icon:hover {
            transform: scale(1.1);
        }

        /* Series Badge */
        .series-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(229, 9, 20, 0.8); /* Using primary color directly */
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.75em;
            font-weight: bold;
            z-index: 5;
        }

        /* Player container base styles (full-screen overlay) */
        .player-container {
            position: fixed;
            background-color: #000; /* Black background for video area */
            border-radius: 0; /* Remove rounded corners for full screen */
            overflow: hidden;
            box-shadow: none; /* Remove box shadow for full screen */
            display: flex;
            flex-direction: column;
            z-index: 9998; /* Ensure it's above everything */
            transition: width 0.3s ease, right 0.3s ease, top 0.3s ease, left 0.3s ease, height 0.3s ease; /* Smooth transition for resizing */
        }

        /* Video element */
        #videoElement {
            width: 100%; /* Video fills its container now */
            height: 100%;
            object-fit: contain; /* Ensure video fits within bounds */
            border-radius: 0; /* No rounded corners for the video itself inside the player container */
        }

        /* When the player container is in fullscreen, make the video element fill it */
        #videoPlayer:-webkit-full-screen #videoElement,
        #videoPlayer:-moz-full-screen #videoElement,
        #videoPlayer:-ms-fullscreen #videoElement,
        #videoPlayer:fullscreen #videoElement {
            width: 100% !important;
            height: 100% !important;
            max-width: none !important;
            max-height: none !important;
            border-radius: 0 !important;
            object-fit: cover !important; /* Change to cover for fullscreen */
            position: absolute !important; /* Ensure it covers the parent */
            top: 0 !important;
            left: 0 !important;
        }

        /* Custom Controls Overlay */
        .controls-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            padding: 1rem;
            opacity: 0; /* Changed for dynamic control */
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Changed for dynamic control */
            display: flex; /* Make it a flex container */
            flex-direction: column; /* Stack content vertically */
            justify-content: flex-end; /* Push content to the bottom */
            align-items: center; /* Center horizontally */
        }
        .controls-overlay.active { /* Class added by JS to show controls */
            opacity: 1;
            pointer-events: auto;
        }

        /* Top Bar: Close Button, Title */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0; /* Changed for dynamic control */
            transition: opacity 0.3s ease-in-out;
            pointer-events: none; /* Changed for dynamic control */
        }
        .top-bar.active { /* Class added by JS to show controls */
            opacity: 1;
            pointer-events: auto;
        }

        /* Close button */
        .close-player-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            transition: color 0.2s;
        }
        .close-player-btn:hover {
            color: var(--primary);
        }

        /* Play/Pause Button */
        .play-pause-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 2.5rem;
            cursor: pointer;
            transition: color 0.2s;
        }
        .play-pause-btn:hover {
            color: var(--primary);
        }

        /* Volume Slider */
        input[type="range"] {
            -webkit-appearance: none;
            width: 80px;
            height: 8px;
            background: #555;
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        /* Progress Bar */
        .progress-bar-container {
            height: 8px;
            background: #555;
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            margin-top: 0.5rem;
            width: 100%; /* Ensure it spans full width of controls-overlay */
        }
        .progress-bar {
            height: 100%;
            background: var(--primary);
            border-radius: 5px;
            width: 0%;
        }
        .progress-scrubber {
            position: absolute;
            top: -5px;
            left: 0%;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden by default */
        }
        .progress-bar-container:hover .progress-scrubber {
            display: block;
        }

        /* Dropdowns */
        .custom-dropdown {
            position: relative;
            display: inline-block;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #282828;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.6);
            z-index: 1;
            bottom: 100%; /* Position above button */
            left: 0;
            border-radius: 8px;
            padding: 0.5rem 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .dropdown-content.right-aligned {
            left: auto;
            right: 0;
        }
        .dropdown-content a, .dropdown-content div {
            color: white;
            padding: 8px 16px;
            text-decoration: none;
            display: block;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .dropdown-content a:hover, .dropdown-content div:hover {
            background-color: var(--primary);
        }
        .dropdown-content a.active, .dropdown-content div.active {
            background-color: var(--primary-dark);
            font-weight: bold;
        }

        /* Next Episode Button */
        .next-episode-btn {
            background-color: var(--primary);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: 600;
            transition: background-color 0.2s;
            cursor: pointer;
            border: none;
        }
        .next-episode-btn:hover {
            background-color: var(--primary-dark);
        }

        /* Password input container for eye icon */
        .password-input-container {
            position: relative;
            width: 100%;
            margin-bottom: 20px; /* Consistent with other inputs */
        }

        .password-input-container input {
            width: 100%;
            padding: 10px;
            padding-right: 40px; /* Make space for the icon */
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: black; /* Force black text */
            border-radius: 5px;
            font-size: 1em;
        }

        .password-input-container .toggle-password-visibility {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            color: var(--text-gray);
        }

        .password-input-container .toggle-password-visibility:hover {
            color: var(--primary);
        }

        /* Cast & Crew Section Styles */
        .cast-crew-section {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px; /* Fixed width for the cast panel */
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Semi-transparent dark background */
            z-index: 9999; /* Above video but below player controls */
            transform: translateX(100%); /* Start off-screen to the right */
            transition: transform 0.3s ease-out;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; /* Enable scrolling for cast list */
            border-left: 1px solid #333;
        }

        .cast-crew-section.active {
            transform: translateX(0); /* Slide in */
        }

        .cast-crew-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .cast-crew-header h3 {
            font-size: 1.5em;
            color: var(--primary);
        }

        .cast-crew-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.8rem;
            cursor: pointer;
            transition: color 0.2s;
        }
        .cast-crew-close-btn:hover {
            color: var(--primary);
        }

        .cast-list {
            display: grid;
            grid-template-columns: 1fr; /* Single column for list */
            gap: 15px;
        }

        .cast-card {
            display: flex;
            align-items: center;
            background-color: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .cast-card:hover {
            background-color: #3a3a3a;
        }

        .cast-card img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 50%; /* Circular image */
            margin-right: 15px;
            flex-shrink: 0;
        }

        .cast-info h4 {
            font-size: 1.1em;
            margin-bottom: 2px;
            color: var(--text);
        }

        .cast-info p {
            font-size: 0.9em;
            color: var(--text-gray);
        }

        /* Cast Detail Modal Styles */
        #castDetailModal {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 10000; /* Above everything */
            justify-content: center;
            align-items: center;
            overflow-y: auto; /* Enable scrolling for modal content */
        }

        .cast-detail-content {
            background-color: var(--bg-light);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.7);
            width: 90%;
            max-width: 700px;
            color: var(--text);
            position: relative;
            max-height: 90vh; /* Limit height for scrollability */
            overflow-y: auto;
        }

        .cast-detail-content .close-modal-btn {
            position: absolute;
            top: 15px;
            right: 25px;
            color: var(--text-gray);
            font-size: 2em;
            cursor: pointer;
            z-index: 1; /* Ensure it's clickable */
        }
        .cast-detail-content .close-modal-btn:hover {
            color: var(--primary);
        }

        .cast-detail-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .cast-detail-header img {
            width: 120px;
            height: 120px;
            object-fit: cover;
            border-radius: 50%;
            margin-right: 25px;
            border: 3px solid var(--primary);
            flex-shrink: 0;
        }

        .cast-detail-header h2 {
            font-size: 2.2em;
            color: var(--primary);
            margin: 0;
        }

        .cast-detail-bio {
            font-size: 1em;
            line-height: 1.7;
            margin-bottom: 25px;
            color: var(--text-gray);
        }

        .known-for-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }

        .known-for-card {
            background-color: var(--card-bg);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            text-align: center;
            padding-bottom: 10px;
            transition: transform 0.2s ease;
        }
        .known-for-card:hover {
            transform: translateY(-3px);
        }

        .known-for-card img {
            width: 100%;
            height: 180px;
            object-fit: cover;
            display: block;
            margin-bottom: 8px;
        }

        .known-for-card h4 {
            font-size: 0.9em;
            color: var(--text);
            padding: 0 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- Mini Player Specific Styles --- */
        .player-container.mini-player {
            width: 700px !important; /* Larger width for mini-player */
            height: 393.75px !important; /* Maintain 16:9 aspect ratio */
            bottom: 40px !important; /* Adjusted position */
            right: 40px !important; /* Adjusted position */
            border-radius: 10px; /* Add some rounded corners back for mini-player */
            box-shadow: 0 6px 20px rgba(0,0,0,0.6); /* More prominent shadow */
        }

        .player-container.mini-player .top-bar,
        .player-container.mini-player .controls-overlay {
            padding: 0.2rem; /* Reduced padding for mini-player controls */
        }

        .player-container.mini-player .close-player-btn {
            font-size: 1.2rem; /* Smaller close button */
        }

        .player-container.mini-player .top-bar .text-xl {
            font-size: 0.8rem; /* Smaller title */
        }

        .player-container.mini-player .top-bar .text-sm {
            font-size: 0.6rem; /* Smaller series info */
        }

        .player-container.mini-player .play-pause-btn {
            font-size: 2rem; /* Larger icon for play/pause */
            width: 40px; /* Fixed size for circular button */
            height: 40px;
        }

        /* Volume Slider */
        .player-container.mini-player input[type="range"] {
            width: 60px; /* Shorter volume slider */
            height: 6px; /* Thinner volume slider */
        }
        input[type="range"]::-webkit-slider-thumb {
            width: 14px; /* Smaller thumb */
            height: 14px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 14px; /* Smaller thumb */
            height: 14px;
        }

        /* Time display */
        .player-container.mini-player .text-sm {
            font-size: 0.8rem; /* Smaller time display */
        }

        /* General button styling within controls-overlay for mini-player */
        .player-container.mini-player .controls-overlay button,
        .player-container.mini-player .controls-overlay .custom-dropdown button {
            font-size: 0.8rem; /* Smaller base font size for buttons */
            padding: 0.2rem 0.3rem; /* Small padding */
            line-height: 1; /* Compact line height */
            height: 30px; /* Fixed height for consistency */
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap; /* Prevent text wrapping if it somehow appears */
        }

        /* Hide text within buttons for mini-player */
        .player-container.mini-player .button-text {
            display: none;
        }

        /* Adjust spacing between buttons in the right control group */
        .player-container.mini-player .flex.items-center.space-x-4 {
            gap: 0.2rem; /* Reduced gap between buttons */
            flex-wrap: nowrap; /* Prevent wrapping, keep them in one line */
            overflow-x: auto; /* Allow horizontal scroll if necessary, though aim to avoid */
            padding-bottom: 2px; /* Small padding for scrollbar if it appears */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            scrollbar-width: none; /* Hide scrollbar for Firefox */
        }
        /* Hide scrollbar for Webkit browsers (Chrome, Safari) */
        .player-container.mini-player .flex.items-center.space-x-4::-webkit-scrollbar {
            display: none;
        }

        /* Next Episode Button */
        .player-container.mini-player .next-episode-btn {
            padding: 0.2rem 0.3rem; /* Even smaller next episode button */
            font-size: 0.8rem; /* Even smaller next episode button text */
        }

        /* Adjust dropdown content for mini player */
        .player-container.mini-player .dropdown-content {
            min-width: 100px; /* Even smaller dropdown width */
            font-size: 0.7rem; /* Even smaller dropdown text */
            padding: 0.2rem 0;
        }
        .player-container.mini-player .dropdown-content a,
        .player-container.mini-player .dropdown-content div {
            padding: 3px 6px;
        }

        /* Player Control Buttons (non-mini-player) - Text on Hover */
        .player-control-button .button-text {
            display: none; /* Hidden by default */
            margin-left: 0.5rem; /* Space between icon and text */
            transition: opacity 0.2s ease-in-out;
            opacity: 0;
            pointer-events: none; /* Ensure text doesn't interfere with click area */
        }

        .player-control-button:hover .button-text {
            display: inline; /* Show on hover */
            opacity: 1;
            pointer-events: auto;
        }

        /* Ensure icon is always visible */
        .player-control-button i {
            display: inline-block;
        }

    </style>

</head>
<body>
<header>
<div class="container flex-row justify-between">
<!-- Header Logo -->
<a class="logo" href="#">
<img src="assets/logos/your-logo-file.png" style="height: 40px; vertical-align: middle;"/>
<!-- Only one instance of "FLM TV" text -->
<span>FLM TV</span>
</a>
<nav>
<ul>
<li><a class="active" href="#" id="homeLink">Home</a></li>
<li><a href="#" id="moviesLink">Movies</a></li>
<li><a href="#" id="tvShowsLink">TV Shows</a></li>
<li><a href="#">Live TV</a></li>
<li><a href="#">Categories</a></li>
<li><a href="#" id="myFavoritesLink" style="display:none;">My Favorites</a></li>
<li><a href="#" id="memberSignUpLink" onclick="openAuthModal('login')">Sign In / Sign Up</a></li>
<li><a href="#" id="memberLogoutLink" style="display:none;">Logout</a></li>
</ul>
</nav>
<!-- Header CHAT Button - REMOVED AS PER USER REQUEST -->
</div>
</header>
<main>
<section class="hero-slideshow" id="hero-slideshow">
</section>
<div class="search-bar-container">
<input id="movieSearchInput" placeholder="Search movies, series, genres..." type="text"/>
</div>
<section class="container">
<h2 class="section-title" id="contentSectionTitle">Latest Releases</h2>
<div class="movie-grid" id="latest-releases-grid">
</div>
</section>
<section class="container" id="liveTvSection">
<h2 class="section-title">Live TV Channels</h2>
<div class="channel-grid" id="live-channels-grid">
</div>
</section>
<section class="container" id="categoriesSection">
<h2 class="section-title">Browse Categories</h2>
<div class="category-grid" id="browse-categories-grid">
</div>
</section>
</main>
<footer>
<div class="container">
<p>Â© 2024 FLM TV. All rights reserved.</p>
<div class="social-links">
<a href="#"><i class="fab fa-facebook-f"></i></a>
<a href="#"><i class="fab fa-twitter"></i></a>
<a href="#"><i class="fab fa-instagram"></i></a>
</div>
</div>
</footer>
<!-- NEW VIDEO PLAYER SECTION -->
<!-- Removed player-backdrop as player-container will now be full screen -->
<div class="player-container" id="videoPlayer" style="display: none;">
<video class="w-full h-full bg-black" id="videoElement" playsinline="">
<!-- Closed captions will be added dynamically -->
</video>
<!-- Top Bar: Close Button, Title -->
<div class="top-bar">
<button class="close-player-btn" id="closePlayerBtn">
<i class="fas fa-times"></i>
</button>
<div class="flex-grow text-center">
<h2 class="text-xl font-bold" id="episodeTitle"></h2>
<p class="text-sm text-gray-400" id="seriesInfo"></p>
</div>
</div>
<!-- Controls Overlay -->
<div class="controls-overlay flex flex-col justify-end p-4">
<!-- Progress Bar -->
<div class="progress-bar-container w-full h-2 bg-gray-700 rounded-full cursor-pointer mb-2" id="progressBarContainer">
<div class="progress-bar h-full bg-red-600 rounded-full" id="progressBar" style="width: 0%;"></div>
<div class="progress-scrubber" id="progressScrubber"></div>
</div>
<div class="flex items-center space-x-4">
<!-- Left Controls: Play/Pause, Volume, Time -->
<div class="flex items-center space-x-4">
<button class="play-pause-btn" id="playPauseBtn">
<i class="fas fa-play"></i>
</button>
<div class="flex items-center space-x-2">
<i class="fas fa-volume-up text-lg"></i>
<input class="w-20" id="volumeSlider" max="1" min="0" step="0.1" type="range" value="1"/>
</div>
<span class="text-sm text-gray-300" id="currentTime">00:00</span> /
                <span class="text-sm text-gray-300" id="duration">00:00</span>
</div>
<!-- Right Controls: Episodes, Captions, Cast & Crew, Fullscreen, Next Episode, Mini Player -->
<div class="flex items-center space-x-4">
<!-- Episodes Dropdown -->
<div class="custom-dropdown" id="episodesDropdown">
<button class="player-control-button bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-md text-sm">
<i class="fas fa-list"></i> <span class="button-text">Episodes</span>
                    </button>
<div class="dropdown-content right-aligned" id="episodesDropdownContent">
<!-- Seasons and Episodes will be populated here by JS -->
</div>
</div>
<!-- Captions Dropdown -->
<div class="custom-dropdown" id="captionsDropdown">
<button class="player-control-button bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-md text-sm">
<i class="fas fa-closed-captioning"></i> <span class="button-text">CC</span>
                    </button>
<div class="dropdown-content right-aligned" id="captionsDropdownContent">
<!-- Captions will be populated here by JS -->
</div>
</div>
<!-- Cast Button (Shortened) -->
<button class="player-control-button bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-md text-sm" id="toggleCastCrewBtn">
            <i class="fas fa-users"></i> <span class="button-text">Cast</span>
        </button>
<!-- Chat Button (inside video player controls) -->
<button class="player-control-button bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-md text-sm" id="playerChatToggleBtn" onclick="toggleChatFromPlayer()">
    <i class="fas fa-comment"></i> <span class="button-text">Chat</span>
</button>
<!-- AI Button (inside video player controls) -->
<button class="player-control-button bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-md text-sm" id="playerAIToggleBtn" onclick="toggleLumaPanel()">
    <i class="fas fa-robot"></i> <span class="button-text">AI</span>
</button>
<!-- Single Screen Size Toggle Button -->
<button class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-3 rounded-md text-sm" id="miniPlayerBtn">
<i class="fas fa-compress"></i> <span class="button-text">Medium Player</span>
                </button>
<!-- Next Episode Button (Moved here) -->
<button class="player-control-button next-episode-btn hidden" id="nextEpisodeBtn">
            <span class="button-text">Next Episode</span> <i class="fas fa-forward"></i>
</button>
</div>
</div>
</div>
<!-- Cast & Crew Section -->
<div class="cast-crew-section" id="castCrewSection">
<div class="cast-crew-header">
<h3>Cast & Crew</h3>
<button class="cast-crew-close-btn" id="closeCastCrewBtn">
<i class="fas fa-times"></i>
</button>
</div>
<div class="cast-list" id="castList">
<!-- Cast members will be loaded here -->
</div>
</div>
</div>
<!-- END NEW VIDEO PLAYER SECTION -->
<!-- Floating Chat Button (main page) -->
<button class="chat-toggle-button-floating" id="chatToggleButtonFloating" onclick="openChat()">
    ð¬
</button>
<!-- Floating LUMA AI Button (main page) -->
<!-- MODIFIED: Changed AI button to use an image icon -->
<button class="luma-toggle-button-floating" id="lumaToggleBtnFloating" onclick="toggleLumaPanel()">
  <img src="assets/images/zaina_ai_avatar.jpg" alt="Zaina AI"/>
</button>

<div id="chatBox">
    <!-- Close button for the chatbox -->
    <button onclick="closeChat()" style="position:absolute;top:5px;right:5px;background:#333;color:white;border:none;padding:4px 8px;border-radius:4px;z-index:10004;cursor:pointer;">â</button>
    <!-- Added allowfullscreen to the iframe for the chatbox -->
    <iframe src="chat/chatbox.html" style="width: 100%; height: 100%; border: none;" allowfullscreen></iframe>
</div>

<!-- AI Panel (Zaina J.) -->
<div id="lumaPanel">
    <button class="close-panel-btn" onclick="closeLumaPanel()">Ã</button>
    <div class="luma-panel-content"> <!-- New inner div for padding -->
        <div class="luma-header">
            <!-- Updated Zaina AI avatar image source -->
            <img alt="Zaina J AI Avatar" src="assets/images/zaina_ai_avatar.jpg"/>
            <h2>Zaina J AI</h2>
        </div>
        <p>Search film info, trailers, actors...</p>
        <input placeholder="Search film..." style="width: 100%; padding: 8px;" type="text"/>
        <button style="margin-top: 10px; width: 100%;">Search</button>
        <!-- Placeholder content for Zaina AI panel -->
        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #333;">
            <h3 style="color: #4CAF50; margin-bottom: 10px;">AI Assistant</h3>
            <p style="font-size: 0.9em; color: #b3b3b3;">
                Hello! I'm Zaina, your personal AI assistant. I can help you find information about movies,
                series, actors, and more. Just type your query above.
            </p>
            <p style="font-size: 0.9em; color: #b3b3b3; margin-top: 10px;">
                Example queries:
                <ul>
                    <li style="margin-left: 20px; list-style-type: disc;">"Tell me about the movie Inception."</li>
                    <li style="margin-left: 20px; list-style-type: disc;">"Who is the director of Oppenheimer?"</li>
                    <li style="margin-left: 20px; list-style-type: disc;">"Show me movies starring Tom Hanks."</li>
                </ul>
            </p>
            <p style="font-size: 0.9em; color: #b3b3b3; margin-top: 10px;">
                (More advanced AI features coming soon!)
            </p>
        </div>
    </div>
</div>

<button class="parent-control-button" onclick="openParentControlModal()">
    ð
</button>
<div id="parentControlModal">
<div class="parent-control-content">
<span class="close-parent-modal" onclick="closeParentControlModal()">Ã</span>
<h2 id="parentControlModalTitle">Parent Control Settings</h2>
<!-- UI for setting/reseting parent code and security question -->
<div id="parentPasswordSetup" style="display: none;">
<p id="parentPasswordSetupMessage" style="text-align: center; margin-bottom: 15px; color: yellow;"></p>
<input id="newParentPassword" maxlength="4" placeholder="Enter new 4-digit code" type="password"/>
<input id="confirmParentPassword" maxlength="4" placeholder="Confirm 4-digit code" style="margin-bottom: 10px;" type="password"/>
<input id="securityQuestion" placeholder="Enter a security question (e.g., Mother's maiden name?)" style="margin-bottom: 10px;" type="text"/>
<input id="securityAnswer" placeholder="Enter the answer" style="margin-bottom: 20px;" type="password"/>
<button class="btn" onclick="setParentCode()" style="width: 100%;">Set Code</button>
<p style="text-align: center; margin-top: 15px; font-size: 0.9em;">
<a href="#" onclick="closeParentControlModal();" style="color: var(--text-gray); text-decoration: none;">Cancel</a>
</p>
</div>
<!-- UI for entering parent code -->
<div id="parentPasswordEntry" style="display: none;">
<input id="parentPassword" maxlength="4" onkeyup="checkParentCode(event)" placeholder="Enter 4-digit code" type="password"/>
<button class="btn" onclick="checkParentCodeManually()" style="width: 100%; margin-top: 10px;">Enter</button>
<p style="margin-top: 10px; text-align: center; font-size: 0.9em;">
<a href="#" onclick="promptForSecurityAnswer()" style="color: var(--primary); text-decoration: none;">Forgot/Change Code?</a>
</p>
</div>
<!-- UI for entering security answer to reset code -->
<div id="parentSecurityQuestionEntry" style="display: none;">
<p id="displayedSecurityQuestion" style="text-align: center; margin-bottom: 15px; font-size: 1.1em;"></p>
<input id="securityAnswerInput" placeholder="Enter your answer" style="margin-bottom: 20px;" type="password"/>
<button class="btn" onclick="verifySecurityAnswer()" style="width: 100%;">Verify Answer</button>
<p style="text-align: center; margin-top: 15px; font-size: 0.9em;">
<a href="#" onclick="openParentControlModal()" style="color: var(--text-gray); text-decoration: none;">Back to Code Entry</a>
</p>
</div>
<!-- Parent Control Toggles (visible after successful code entry/setup) -->
<div id="controlToggles" style="display: none;">
<label>
                Hide Chat
                <span class="toggle-switch">
<input id="toggleHideChat" type="checkbox"/>
<span class="slider round"></span>
</span>
</label>
<div class="mt-4 mb-4 pt-4 border-t border-gray-700">
<h3 class="text-lg font-semibold mb-3">Block Content by Rating:</h3>
<div class="grid grid-cols-2 gap-2">
<label class="flex items-center">
<input class="mr-2" id="toggleBlockRatingG" type="checkbox"/> G
                        </label>
<label class="flex items-center">
<input class="mr-2" id="toggleBlockRatingPG" type="checkbox"/> PG
                        </label>
<label class="flex items-center">
<input class="mr-2" id="toggleBlockRatingPG13" type="checkbox"/> PG-13
                        </label>
<label class="flex items-center">
<input class="mr-2" id="toggleBlockRatingR" type="checkbox"/> R
                        </label>
<label class="flex items-center">
<input class="mr-2" id="toggleBlockRatingNC17" type="checkbox"/> NC-17/X
                        </label>
</div>
</div>
<label class="mt-4">
                Hide 'Horror' Category
                <span class="toggle-switch">
<input id="toggleHideHorror" type="checkbox"/>
<span class="slider round"></span>
</span>
</label>
<label class="mt-4">
                Block Live TV Channels
                <span class="toggle-switch">
<input id="toggleBlockLiveTV" type="checkbox"/>
<span class="slider round"></span>
</span>
</label>
<button class="btn" onclick="saveParentSettings()" style="width: 100%; margin-top: 20px;">Save Settings</button>
</div>
</div>
</div>
<!-- Original Member Auth Modal HTML (Restored) -->
<div id="memberAuthModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; justify-content: center; align-items: center;">
<div style="background: #222; padding: 30px; border-radius: 8px; width: 360px; color: white; position: relative;">
<span class="close-auth-modal" onclick="closeAuthModal()" style="position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 20px;">â</span>
<h3 id="authModalTitle">Sign In</h3>
<input autocomplete="email" id="authEmail" placeholder="Email Address" style="width:100%; padding:8px; margin-top:10px;"/>
<div class="password-input-container">
<input autocomplete="current-password" id="authPassword" placeholder="Password" type="password"/>
<i class="fas fa-eye toggle-password-visibility" id="toggleAuthPassword"></i>
</div>
<p style="margin-top: 10px; text-align: right;">
<a href="#" onclick="handleForgotPassword()" style="color: #ccc; font-size: 0.9rem;">Forgot Password?</a>
</p>
<button id="authSubmitBtn" style="width:100%; padding:10px; background:var(--primary); color:white; border:none; margin-top:10px;">Log In</button>
<p style="margin-top:15px; text-align:center;">
<span id="authModeToggleText">Not a member?</span>
<a href="#" id="authModeToggleLink" style="color: var(--primary);">Sign Up</a>
</p>
<button id="upgradePremiumBtn" onclick="alert('Upgrade clicked (mock)!')" style="margin-top:15px; width:100%; padding:8px; background:#555; color:white; border:none;">ð Try Paid Membership</button>
<div id="memberStatusMessage" style="margin-top: 10px; font-size: 0.9rem;"></div>
<!-- Message display for chat/AI login requirement -->
<div id="tempAuthMessage" style="margin-top: 15px; text-align: center; color: orange; display: none; font-weight: bold; padding: 10px; border: 1px solid orange; border-radius: 5px;"></div>
</div>
</div>

<!-- Cast Detail Modal -->
<div id="castDetailModal">
<div class="cast-detail-content">
<span class="close-modal-btn" onclick="closeCastDetailsModal()">Ã</span>
<div class="cast-detail-header">
<img alt="Actor Profile" id="castDetailImage" src="https://placehold.co/120x120?text=Actor"/>
<h2 id="castDetailName"></h2>
</div>
<p class="cast-detail-bio" id="castDetailBio"></p>
<h3>Known For:</h3>
<div class="known-for-grid" id="knownForGrid">
<!-- Known for titles will be loaded here -->
</div>
</div>
</div>

<script>
    // TMDB API Key - REPLACE WITH YOUR ACTUAL KEY
    const TMDB_API_KEY = 'your_tmdb_api_key_here'; // Updated with user provided key
    const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
    const TMDB_IMAGE_BASE_URL = 'https://image.themoviedb.org/t/p/w500'; // For larger images (posters, profiles)
    const TMDB_PROFILE_SMALL_URL = 'https://image.themoviedb.org/t/p/w185'; // For cast list profiles

    // Mock TV Series Data - Used by the new player for episode management
    // This is the default structure for when a series is played without a specific seriesId from allMovies
    const tvSeriesData = {
        title: "The Chronicles of Eldoria",
        seriesId: "eldoria", // Added seriesId here for easy lookup
        seasons: [
            {
                seasonNumber: 1,
                episodes: [
                    { id: "s1e1", title: "A New Beginning", videoUrl: "https://www.w3schools.com/html/mov_bbb.mp4", captions: [{ lang: "en", label: "English", src: "data:text/vtt;base64," + btoa("WEBVTT\\n\\n1\\n00:00:01.000 --> 00:00:04.000\\nHello, and welcome to Eldoria.\\n\\n2\\n00:00:05.000 --> 00:00:08.000\\nThis is the first episode.") }, { lang: "es", label: "EspaÃ±ol", src: "data:text/vtt;base64," + btoa("WEBVTT\\n\\n1\\n00:00:01.000 --> 00:00:04.000\\nHola, y bienvenidos a Eldoria.\\n\\n2\\n00:00:05.000 --> 00:00:08.000\\nEste es el primer episodio.") }] }
                ]
            }
        ]
    };

    // DOM Elements for the new player
    const videoPlayer = document.getElementById('videoPlayer');
    const videoElement = document.getElementById('videoElement');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const volumeSlider = document.getElementById('volumeSlider');
    const currentTimeSpan = document.getElementById('currentTime');
    const durationSpan = document.getElementById('duration');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBar = document.getElementById('progressBar');
    const progressScrubber = document.getElementById('progressScrubber');
    const miniPlayerBtn = document.getElementById('miniPlayerBtn'); // Now the single resize button
    const closePlayerBtn = document.getElementById('closePlayerBtn');
    const episodeTitle = document.getElementById('episodeTitle');
    const seriesInfo = document.getElementById('seriesInfo');
    const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');
    const episodesDropdown = document.getElementById('episodesDropdown');
    const episodesDropdownContent = document.getElementById('episodesDropdownContent');
    const captionsDropdown = document.getElementById('captionsDropdown');
    const captionsDropdownContent = document.getElementById('captionsDropdownContent');
    const controlsOverlay = document.querySelector('.controls-overlay'); // Get reference to controls overlay
    const topBar = document.querySelector('.top-bar'); // Get reference to top bar
    const chatToggleButtonFloating = document.getElementById('chatToggleButtonFloating'); // Reference to floating chat button
    const lumaToggleBtnFloating = document.getElementById('lumaToggleBtnFloating'); // Reference to floating LUMA AI button
    const chatBox = document.getElementById('chatBox'); // Reference to chat box
    const lumaPanel = document.getElementById('lumaPanel'); // Reference to AI panel
    const playerAIToggleBtn = document.getElementById('playerAIToggleBtn'); // Reference to AI button in player controls
    const playerChatToggleBtn = document.getElementById('playerChatToggleBtn'); // Reference to Chat button in player controls
    const liveTvSection = document.getElementById('liveTvSection'); // Reference to Live TV section
    const categoriesSection = document.getElementById('categoriesSection'); // Reference to Categories section
    const tvShowsLink = document.getElementById('tvShowsLink'); // Reference to TV Shows header link
    const tempAuthMessage = document.getElementById('tempAuthMessage'); // New message display for login requirement


    // NEW Cast & Crew Elements
    const toggleCastCrewBtn = document.getElementById('toggleCastCrewBtn');
    const castCrewSection = document.getElementById('castCrewSection');
    const closeCastCrewBtn = document.getElementById('closeCastCrewBtn');
    const castListContainer = document.getElementById('castList');
    const castDetailModal = document.getElementById('castDetailModal');
    const castDetailImage = document.getElementById('castDetailImage');
    const castDetailName = document.getElementById('castDetailName');
    const castDetailBio = document.getElementById('castDetailBio');
    const knownForGrid = document.getElementById('knownForGrid');


    let currentSeasonIndex = 0;
    let currentEpisodeIndex = 0;
    let currentPlayingContent = null; // To store details of the currently playing movie/episode
    let controlsTimeout; // Variable to hold the timeout for hiding controls
    let screenMode = 'full'; // Track current screen mode: 'full', 'medium', 'small'

    // --- Core Player Functions (from player3.html, adapted) ---

    /**
     * Toggles play/pause state of the video.
     */
    function togglePlayPause() {
        if (videoElement.paused || videoElement.ended) {
            videoElement.play();
        } else {
            videoElement.pause();
        }
    }

    /**
     * Updates the play/pause button icon based on video state.
     */
    function updatePlayPauseIcon() {
        playPauseBtn.querySelector('i').className = videoElement.paused ? 'fas fa-play' : 'fas fa-pause';
    }

    /**
     * Updates current time and duration display.
     */
    function updateTime() {
        const formatTime = (seconds) => {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        };
        currentTimeSpan.textContent = formatTime(videoElement.currentTime);
        if (videoElement.duration && isFinite(videoElement.duration)) { // Check for finite duration
            durationSpan.textContent = formatTime(videoElement.duration);
        } else {
            durationSpan.textContent = '00:00'; // Default if duration is not available yet
        }
    }

    /**
     * Updates the progress bar and scrubber position.
     */
    function updateProgressBar() {
        if (videoElement.duration && isFinite(videoElement.duration)) {
            const progress = (videoElement.currentTime / videoElement.duration) * 100;
            progressBar.style.width = `${progress}%`;
            progressScrubber.style.left = `${progress}%`;
        }
    }

    /**
     * Handles seeking when the progress bar is clicked.
     * @param {MouseEvent} e - The click event.
     */
    function seek(e) {
        if (videoElement.duration && isFinite(videoElement.duration)) {
            const clickX = e.offsetX;
            const width = progressBarContainer.offsetWidth;
            const seekTime = (clickX / width) * videoElement.duration;
            videoElement.currentTime = seekTime;
        }
    }

    /**
     * Shows the player controls (top bar, overlay) and sets a timeout to hide them.
     */
    function showControls() {
        clearTimeout(controlsTimeout); // Clear any existing timeout
        controlsOverlay.classList.add('active');
        topBar.classList.add('active');

        // Hide floating buttons when player controls are active
        chatToggleButtonFloating.style.opacity = '0';
        chatToggleButtonFloating.style.pointerEvents = 'none';
        lumaToggleBtnFloating.style.opacity = '0';
        lumaToggleBtnFloating.style.pointerEvents = 'none';

        // Hide controls after 2 seconds of inactivity, unless paused or a dropdown is open
        const isDropdownOpen = episodesDropdownContent.style.display === 'block' || captionsDropdownContent.style.display === 'block';
        if (!videoElement.paused && !isDropdownOpen) {
            controlsTimeout = setTimeout(() => {
                hideControls();
            }, 2000); // 2 seconds
        }
    }

    /**
     * Hides the player controls (top bar and overlay).
     */
    function hideControls() {
        // Only hide if video is playing AND no dropdowns are open
        const isDropdownOpen = episodesDropdownContent.style.display === 'block' || captionsDropdownContent.style.display === 'block';
        if (!videoElement.paused && !isDropdownOpen) {
            controlsOverlay.classList.remove('active');
            topBar.classList.remove('active');
        }
        // Re-evaluate floating button visibility after controls hide
        applyParentSettings(); // This will show them if player is not active
    }

    /**
     * Toggles native browser fullscreen mode for the video player.
     * This is separate from the windowed screen modes.
     */
    function toggleNativeFullscreen() {
        console.log("toggleNativeFullscreen: Attempting native fullscreen...");
        if (!document.fullscreenElement) {
            videoPlayer.requestFullscreen().then(() => {
                console.log("toggleNativeFullscreen: Fullscreen requested successfully.");
                showControls(); // Show controls when entering fullscreen
            }).catch(err => {
                console.error(`toggleNativeFullscreen: Error attempting to enable fullscreen: ${err.message} (${err.name})`);
                // Using the new message display for fullscreen errors
                showTempAuthMessage("Fullscreen might be disallowed by your browser's security settings or the embedding environment (e.g., iframe).", 'orange');
            });
        } else {
            document.exitFullscreen().then(() => {
                console.log("toggleNativeFullscreen: Exited fullscreen successfully.");
                hideControls(); // Hide controls when exiting fullscreen
            });
        }
    }

    /**
     * Updates the text/icons of player control buttons based on whether mini-player mode is active.
     * @param {boolean} isMiniPlayer - True if mini-player mode is active, false otherwise.
     */
    function updatePlayerControlButtons(isMiniPlayer) {
        const buttons = [
            { id: 'episodesDropdown', icon: 'fas fa-list', text: 'Episodes' },
            { id: 'captionsDropdown', icon: 'fas fa-closed-captioning', text: 'CC' },
            { id: 'toggleCastCrewBtn', icon: 'fas fa-users', text: 'Cast' },
            { id: 'playerChatToggleBtn', icon: 'fas fa-comment', text: 'Chat' },
            { id: 'playerAIToggleBtn', icon: 'fas fa-robot', text: 'AI' },
            { id: 'nextEpisodeBtn', icon: 'fas fa-forward', text: 'Next Episode' } // Include next episode button
        ];

        buttons.forEach(btnInfo => {
            // Special handling for dropdown buttons to get the actual button element
            const buttonElement = document.getElementById(btnInfo.id).querySelector('button') || document.getElementById(btnInfo.id);

            if (buttonElement) {
                const textElement = buttonElement.querySelector('.button-text');

                if (isMiniPlayer) {
                    if (textElement) textElement.style.display = 'none';
                    // Ensure only icon is visible for mini-player
                    buttonElement.innerHTML = `<i class="${btnInfo.icon}"></i>`;
                } else {
                    // For non-mini-player, text is initially hidden by CSS and shown on hover
                    // We just need to ensure the HTML structure is correct.
                    if (textElement) {
                        textElement.style.display = 'none'; // Keep hidden, CSS will show on hover
                    }
                    buttonElement.innerHTML = `<i class="${btnInfo.icon}"></i> <span class="button-text">${btnInfo.text}</span>`;
                }
            }
        });

        // Update the miniPlayerBtn's text/icon based on the *next* state, not current
        updateMiniPlayerButtonText();
    }


    /**
     * Helper to update the text/icon of the single resize button based on the current screenMode.
     * This is called by togglePlayerMode and openPlayer.
     */
    function updateMiniPlayerButtonText() {
        // The miniPlayerBtn's text should always be visible (unless in 'small' mode, where it's hidden by CSS)
        // and reflect the *next* state it will transition to.
        const textSpan = miniPlayerBtn.querySelector('.button-text');

        if (screenMode === "full") {
            miniPlayerBtn.innerHTML = '<i class="fas fa-compress"></i> <span class="button-text">Medium Player</span>';
        } else if (screenMode === "medium") {
            miniPlayerBtn.innerHTML = '<i class="fas fa-compress"></i> <span class="button-text">Small Player</span>';
        } else { // screenMode === "small"
            miniPlayerBtn.innerHTML = '<i class="fas fa-expand-arrows-alt"></i> <span class="button-text">Full Window</span>';
            // Explicitly hide text for small player mode
            const currentTextSpan = miniPlayerBtn.querySelector('.button-text');
            if (currentTextSpan) currentTextSpan.style.display = 'none';
        }
    }


    /**
     * Toggles between full, medium, and small player modes (windowed).
     * This is the unified button logic.
     */
    function togglePlayerMode() {
        console.log("togglePlayerMode: Current screen mode BEFORE change:", screenMode);
        const player = videoPlayer; // Reference to the player container

        if (document.fullscreenElement) {
            // If currently in native fullscreen, exit it first
            document.exitFullscreen();
            // The fullscreenchange event listener will handle setting screenMode back to 'full'
            // and updating the button text/icon after exiting native fullscreen.
            return; // Exit function, as fullscreenchange listener will handle next steps
        }

        if (screenMode === "full") {
            // Transition to medium screen
            player.style.width = "70%";
            player.style.height = "70%";
            player.style.top = "15%";
            player.style.left = "15%";
            player.style.right = "auto"; // Reset right
            player.style.bottom = "auto"; // Reset bottom
            player.classList.remove('mini-player'); // Ensure mini-player class is off
            document.body.style.overflow = 'auto'; // Re-enable main page scrolling
            screenMode = "medium";
        } else if (screenMode === "medium") {
            // Transition to small screen (mini-player)
            player.style.width = "700px"; /* Increased width */
            player.style.height = "393.75px"; /* Increased height (16:9 aspect ratio) */
            player.style.bottom = "40px"; /* Adjusted position */
            player.style.right = "40px"; /* Adjusted position */
            player.style.top = "auto";
            player.style.left = "auto";
            player.classList.add('mini-player');
            document.body.style.overflow = 'auto'; // Keep main page scrolling
            screenMode = "small";
        } else { // screenMode === "small"
            // Transition back to full screen (windowed)
            player.style.width = "100%";
            player.style.height = "100%";
            player.style.top = "0";
            player.style.left = "0";
            player.style.right = "0";
            player.style.bottom = "0";
            player.classList.remove('mini-player'); // Remove mini-player class
            document.body.style.overflow = 'hidden'; // Disable main page scrolling
            screenMode = "full";
        }
        console.log(`togglePlayerMode: New screen mode: ${screenMode}, Player dimensions: W:${player.style.width} H:${player.style.height}`);

        updateMiniPlayerButtonText(); // Update the text/icon of the resize button
        updatePlayerControlButtons(screenMode === 'small'); // Update other control buttons

        // Adjust player position if chat or AI panel is open
        adjustPlayerForPanel(); // Call without arguments, it will determine state internally
        showControls(); // Ensure controls are visible after mode change
    }


    /**
     * Loads a specific episode into the player (for series).
     * This function is primarily for internal series navigation.
     * For movies, `openPlayer` will handle the initial load.
     * @param {number} seasonIdx - Index of the season.
     * @param {number} episodeIdx - Index of the episode within the season.
     */
    function loadEpisode(seasonIdx, episodeIdx) {
        console.log(`loadEpisode: Loading S${seasonIdx + 1} E${episodeIdx + 1}`);
        currentSeasonIndex = seasonIdx;
        currentEpisodeIndex = episodeIdx;

        const season = tvSeriesData.seasons[seasonIdx];
        const episode = season.episodes[episodeIdx];

        if (!episode) {
            console.error("loadEpisode: Episode not found.");
            return;
        }

        videoElement.src = episode.videoUrl;
        episodeTitle.textContent = episode.title;
        seriesInfo.textContent = `Season ${season.seasonNumber}, Episode ${episodeIdx + 1} of ${tvSeriesData.title}`;

        // Clear existing tracks
        Array.from(videoElement.children).forEach(child => {
            if (child.tagName === 'TRACK') {
                videoElement.removeChild(child);
            }
        });

        // Add new caption tracks
        if (episode.captions && episode.captions.length > 0) {
            episode.captions.forEach(caption => {
                const track = document.createElement('track');
                track.kind = 'captions';
                track.label = caption.label;
                track.srclang = caption.lang;
                track.src = caption.src;
                if (caption.default) {
                    track.default = true;
                }
                videoElement.appendChild(track);
            });
        }

        videoElement.load(); // Load the new source
        videoElement.pause(); // Ensure it's paused initially
        updatePlayPauseIcon(); // Set icon to 'play'
        renderCaptionsDropdown(); // Re-render captions dropdown for new episode
        updateNextEpisodeButtonVisibility(); // Update next episode button
    }

    /**
     * Plays the next episode in the series.
     */
    function playNextEpisode() {
        console.log("playNextEpisode: Attempting to play next episode.");
        const currentSeason = tvSeriesData.seasons[currentSeasonIndex];
        if (currentEpisodeIndex < currentSeason.episodes.length - 1) {
            loadEpisode(currentSeasonIndex, currentEpisodeIndex + 1);
            videoElement.play(); // Play next episode automatically
        } else if (currentSeasonIndex < tvSeriesData.seasons.length - 1) {
            loadEpisode(currentSeasonIndex + 1, 0); // Move to next season, first episode
            videoElement.play(); // Play next episode automatically
        } else {
            console.log("playNextEpisode: End of series.");
            videoElement.pause();
            // Optionally show "Watch Again" or "More Like This"
        }
    }

    /**
     * Updates the visibility of the "Next Episode" button.
     */
    function updateNextEpisodeButtonVisibility() {
        // Only show for series content
        if (currentPlayingContent && currentPlayingContent.isSeries) {
            const currentSeason = tvSeriesData.seasons[currentSeasonIndex];
            const hasNextEpisodeInSeason = currentEpisodeIndex < currentSeason.episodes.length - 1;
            const hasNextSeason = currentSeasonIndex < tvSeriesData.seasons.length - 1;

            if (hasNextEpisodeInSeason || hasNextSeason) {
                nextEpisodeBtn.classList.remove('hidden');
            } else {
                nextEpisodeBtn.classList.add('hidden');
            }
        } else {
            nextEpisodeBtn.classList.add('hidden'); // Always hide for movies
        }
    }

    // --- Dropdown Management ---

    /**
     * Toggles the visibility of a dropdown.
     * @param {HTMLElement} dropdownContent - The dropdown content element.
     */
    function toggleDropdown(dropdownContent) {
        console.log("toggleDropdown: Toggling", dropdownContent.id);
        dropdownContent.style.display = dropdownContent.style.display === 'block' ? 'none' : 'block';
    }

    /**
     * Renders the episodes and seasons in the dropdown.
     */
    function renderEpisodesDropdown() {
        console.log("renderEpisodesDropdown: Rendering episodes dropdown for series:", tvSeriesData.title);
        episodesDropdownContent.innerHTML = ''; // Clear previous content

        if (!tvSeriesData.seasons || tvSeriesData.seasons.length === 0) {
            episodesDropdownContent.innerHTML = '<div class="px-4 py-2 text-gray-400">No seasons available.</div>';
            return;
        }

        tvSeriesData.seasons.forEach((season, sIdx) => {
            const seasonHeader = document.createElement('div');
            seasonHeader.className = 'font-bold px-4 py-2 text-gray-300';
            seasonHeader.textContent = `Season ${season.seasonNumber}`;
            episodesDropdownContent.appendChild(seasonHeader);

            if (!season.episodes || season.episodes.length === 0) {
                const noEpisodes = document.createElement('div');
                noEpisodes.className = 'px-4 py-2 text-gray-400 text-xs';
                noEpisodes.textContent = 'No episodes for this season.';
                episodesDropdownContent.appendChild(noEpisodes);
                return;
            }

            season.episodes.forEach((episode, eIdx) => {
                const episodeItem = document.createElement('div');
                episodeItem.className = 'px-4 py-2 hover:bg-red-600 cursor-pointer';
                if (sIdx === currentSeasonIndex && eIdx === currentEpisodeIndex) {
                    episodeItem.classList.add('active');
                }
                episodeItem.textContent = `E${eIdx + 1}: ${episode.title}`;
                episodeItem.onclick = () => {
                    loadEpisode(sIdx, eIdx);
                    videoElement.play(); // Play episode when selected from dropdown
                    toggleDropdown(episodesDropdownContent); // Close dropdown after selection
                };
                episodesDropdownContent.appendChild(episodeItem);
            });
        });
        console.log("renderEpisodesDropdown: Episodes dropdown content populated. InnerHTML length:", episodesDropdownContent.innerHTML.length);
    }

    /**
     * Renders the available captions in the dropdown.
     */
    function renderCaptionsDropdown() {
        console.log("renderCaptionsDropdown: Rendering captions dropdown...");
        captionsDropdownContent.innerHTML = ''; // Clear previous content

        // Option to turn captions off
        const offOption = document.createElement('div');
        offOption.className = 'px-4 py-2 hover:bg-red-600 cursor-pointer';
        offOption.textContent = 'Off';
        offOption.onclick = () => {
            Array.from(videoElement.textTracks).forEach(track => track.mode = 'hidden');
            toggleDropdown(captionsDropdownContent);
        };
        captionsDropdownContent.appendChild(offOption);

        // Add options for each available caption track
        Array.from(videoElement.textTracks).forEach(track => {
            if (track.kind === 'captions' || track.kind === 'subtitles') {
                const captionOption = document.createElement('div');
                captionOption.className = 'px-4 py-2 hover:bg-red-600 cursor-pointer';
                captionOption.textContent = track.label;
                captionOption.onclick = () => {
                    // Hide all tracks first
                    Array.from(videoElement.textTracks).forEach(t => t.mode = 'hidden');
                    // Then enable the selected one
                    track.mode = 'showing';
                    toggleDropdown(captionsDropdownContent); // Close dropdown
                };
                captionsDropdownContent.appendChild(captionOption);
            }
        });
        console.log("renderCaptionsDropdown: Captions dropdown content populated. Total tracks:", videoElement.textTracks.length);
    }

    // --- Main `openPlayer` and `closePlayer` functions (adapted for new player) ---
    function openPlayer(videoSrc, contentTitle = "Video Playback", contentType = "movie", contentDetails = null, mode = 'full') { // Default mode is 'full'
        console.log("openPlayer called. contentType:", contentType, "contentDetails:", contentDetails, "mode:", mode);

        // Ensure AI panel is closed when player opens
        lumaPanel.style.display = 'none';
        lumaPanel.style.right = '0px'; // Reset position
        chatBox.style.display = 'none'; // Ensure chat is also closed
        chatBox.style.right = '0px'; // Reset position

        screenMode = mode; // Set the initial screen mode

        // Apply styles based on initial mode
        const player = videoPlayer;
        if (mode === 'full') {
            player.style.width = '100%';
            player.style.height = '100%';
            player.style.top = '0';
            player.style.left = '0';
            player.style.right = '0';
            player.style.bottom = '0';
            player.classList.remove('mini-player'); // Ensure mini-player class is off
            document.body.style.overflow = 'hidden'; // Prevent main page scrolling
        } else if (mode === 'medium') {
            player.style.width = "70%";
            player.style.height = "70%";
            player.style.top = "15%";
            player.style.left = "15%";
            player.style.right = "auto";
            player.style.bottom = "auto";
            player.classList.remove('mini-player');
            document.body.style.overflow = 'auto';
        } else { // 'small' mode
            player.style.width = "700px"; /* Increased width */
            player.style.height = "393.75px"; /* Increased height (16:9 aspect ratio) */
            player.style.bottom = "40px"; /* Adjusted position */
            player.style.right = "40px"; /* Adjusted position */
            player.style.top = "auto";
            player.style.left = "auto";
            player.classList.add('mini-player');
            document.body.style.overflow = 'auto';
        }

        videoPlayer.style.display = 'flex'; // Show the player container
        console.log("openPlayer: videoPlayer display style after setting:", videoPlayer.style.display);

        updateMiniPlayerButtonText(); // Update the text/icon of the resize button
        updatePlayerControlButtons(screenMode === 'small'); // Update other control buttons

        // Reset player state
        videoElement.currentTime = 0;
        updateProgressBar();
        updateTime();
        updatePlayPauseIcon();

        if (contentType === 'movie') {
            videoElement.src = videoSrc; // Set video source directly for movies
            episodeTitle.textContent = contentTitle;
            seriesInfo.textContent = "Movie";
            nextEpisodeBtn.classList.add('hidden'); // Hide next episode button for movies
            episodesDropdown.style.display = 'none'; // Hide episodes dropdown for movies
            currentPlayingContent = { isSeries: false, ...contentDetails }; // Store all movie details
            console.log("openPlayer: Player opened for Movie. Episodes dropdown display:", episodesDropdown.style.display);
            loadCastAndCrew(contentDetails); // Load cast for the movie


            // Clear existing tracks for movies
            Array.from(videoElement.children).forEach(child => {
                if (child.tagName === 'TRACK') {
                    videoElement.removeChild(child);
                }
            });
            renderCaptionsDropdown(); // Re-render captions dropdown (will only show 'Off' if no tracks)

        } else if (contentType === 'series' && contentDetails && contentDetails.seriesId) {
            console.log("openPlayer: Detected series content. Series ID:", contentDetails.seriesId);
            // Find the full series data from allMovies (which is now populated from mock data)
            const fullSeriesData = allMovies.find(item => item.id === contentDetails.seriesId && item.type === 'series');
            if (fullSeriesData) {
                // IMPORTANT: Use the global tvSeriesData for episode management
                // This is crucial for series to work with multiple seasons/episodes
                Object.assign(tvSeriesData, fullSeriesData); // Merge fullSeriesData into tvSeriesData
                currentPlayingContent = {
                    isSeries: true,
                    seriesTitle: tvSeriesData.title,
                    seriesId: tvSeriesData.id,
                    ...fullSeriesData // Pass all series details including seasons/episodes
                };
                loadEpisode(0, 0); // Load Season 1, Episode 1 by default
                episodesDropdown.style.display = 'inline-block'; // Make sure episodes dropdown is visible
                console.log("openPlayer: Player opened for Series. Episodes dropdown display:", episodesDropdown.style.display);
                renderEpisodesDropdown(); // Populate episodes dropdown
                updateNextEpisodeButtonVisibility();
                loadCastAndCrew(fullSeriesData); // Load cast for the series
            } else {
                console.error("openPlayer: Series data not found in allMovies for ID:", contentDetails.seriesId);
                // Fallback for series not found, maybe play a generic video or show an error
                videoElement.src = "https://www.w3schools.com/html/mov_bbb.mp4"; // Fallback video
                episodeTitle.textContent = "Error: Series Not Found";
                seriesInfo.textContent = "";
                nextEpisodeBtn.classList.add('hidden');
                episodesDropdown.style.display = 'none';
            }
        }

        videoElement.play().catch(error => {
            console.warn("openPlayer: Autoplay prevented or failed:", error);
            // Optionally, show a play button overlay if autoplay fails
        });

        // Hide floating chat and AI buttons when player is active
        chatToggleButtonFloating.style.opacity = '0';
        chatToggleButtonFloating.style.pointerEvents = 'none';
        lumaToggleBtnFloating.style.opacity = '0';
        lumaToggleBtnFloating.style.pointerEvents = 'none';

        // Adjust player width if chat or AI panel is already open
        adjustPlayerForPanel(); // Call without arguments, it will determine state internally
        showControls(); // Show controls when player is opened
    }

    function closePlayer() {
        console.log("closePlayer: Closing player.");
        document.body.style.overflow = 'auto'; // Re-enable main page scrolling
        videoElement.pause();
        videoElement.removeAttribute('src'); // Clear src to prevent background audio
        videoPlayer.style.display = 'none'; // Hide the player
        videoPlayer.classList.remove('mini-player'); // Ensure mini-player class is removed

        // Hide chat box and AI panel and reset their positions
        chatBox.style.display = 'none';
        chatBox.style.right = '0px';
        lumaPanel.style.display = 'none';
        lumaPanel.style.right = '0px';


        // Hide cast & crew section and modal
        castCrewSection.classList.remove('active');
        closeCastDetailsModal();

        hideControls(); // Ensure controls are hidden when player closes
        // Reset player width/position
        videoPlayer.style.width = '100%';
        videoPlayer.style.right = '0';
        videoPlayer.style.top = '0';
        videoPlayer.style.left = '0';
        videoPlayer.style.bottom = '0';
        console.log("closePlayer: Player closed, UI restored.");
        applyParentSettings(); // Re-evaluate floating buttons visibility
    }

    /**
     * Adjusts the video player's size and position to accommodate the chatbox or AI panel.
     */
    function adjustPlayerForPanel() {
        const isChatOpen = chatBox.style.display === 'block';
        const isLumaOpen = lumaPanel.style.display === 'flex'; // Changed to 'flex' for lumaPanel
        const panelWidth = 380; // Fixed width of each panel

        let totalPanelWidth = 0;
        if (isChatOpen) totalPanelWidth += panelWidth;
        if (isLumaOpen) totalPanelWidth += panelWidth;

        console.log(`adjustPlayerForPanel: isChatOpen=${isChatOpen}, isLumaOpen=${isLumaOpen}, totalPanelWidth=${totalPanelWidth}, screenMode=${screenMode}`);

        // Adjust player width and right position
        if (totalPanelWidth > 0) {
            if (screenMode === 'full') {
                videoPlayer.style.width = `calc(100% - ${totalPanelWidth}px)`;
                videoPlayer.style.right = `${totalPanelWidth}px`;
                videoPlayer.style.left = '0'; // Ensure left is reset
            } else if (screenMode === 'medium') {
                // For medium, adjust left to simulate shrinking from right
                // Recalculate left based on new width to keep it centered relative to the *remaining* space or just shift it
                const baseWidth = 0.7 * window.innerWidth; // 70% of viewport width
                const newWidth = baseWidth - totalPanelWidth;
                videoPlayer.style.width = `${newWidth}px`;
                // This centering logic might need adjustment if the player is not perfectly centered initially
                videoPlayer.style.left = `calc(50% - ${newWidth / 2}px)`;
                videoPlayer.style.right = 'auto';
            } else if (screenMode === 'small') {
                // For small (mini-player), just move it left to avoid overlap
                videoPlayer.style.right = `${40 + totalPanelWidth}px`; /* Adjusted for new mini-player right */
            }
        } else {
            // No panels open, restore player to its original position/size for the current screenMode
            if (screenMode === 'full') {
                videoPlayer.style.width = '100%';
                videoPlayer.style.right = '0';
                videoPlayer.style.left = '0';
            } else if (screenMode === 'medium') {
                videoPlayer.style.width = '70%';
                videoPlayer.style.left = '15%';
                videoPlayer.style.right = 'auto';
            } else if (screenMode === 'small') {
                videoPlayer.style.right = '40px'; // Revert to default mini-player right
            }
        }
        console.log(`adjustPlayerForPanel: Player new width=${videoPlayer.style.width}, new right=${videoPlayer.style.right}, new left=${videoPlayer.style.left}`);
    }


    // --- Event Listeners for the new player ---
    playPauseBtn.addEventListener('click', togglePlayPause);
    videoElement.addEventListener('play', updatePlayPauseIcon);
    videoElement.addEventListener('pause', updatePlayPauseIcon);
    videoElement.addEventListener('timeupdate', updateTime);
    videoElement.addEventListener('timeupdate', updateProgressBar);
    videoElement.addEventListener('loadedmetadata', updateTime); // Update duration when metadata loads

    volumeSlider.addEventListener('input', (e) => {
        videoElement.volume = e.target.value;
    });

    progressBarContainer.addEventListener('click', seek);

    // Unified screen size toggle button
    miniPlayerBtn.addEventListener('click', () => {
        console.log("miniPlayerBtn (unified) clicked."); // Log click
        togglePlayerMode();
    });

    // Double-click on video for native fullscreen
    videoElement.addEventListener('dblclick', toggleNativeFullscreen);

    // Single click on video to toggle player mode if in small mode, otherwise just show controls
    videoElement.addEventListener('click', (e) => {
        // Prevent event from bubbling up and interfering with controls overlay click
        e.stopPropagation();
        if (screenMode === 'small') {
            console.log("Video element clicked in small mode. Toggling player mode.");
            togglePlayerMode(); // Cycle from small -> full window
        } else {
            // If not in small mode, just show controls on click
            showControls();
        }
    });


    closePlayerBtn.addEventListener('click', closePlayer); // Use the unified closePlayer function

    nextEpisodeBtn.addEventListener('click', playNextEpisode);

    // Dropdown toggles
    episodesDropdown.querySelector('button').addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent document click from closing immediately
        toggleDropdown(episodesDropdownContent);
        // Close other dropdowns
        captionsDropdownContent.style.display = 'none';
    });

    captionsDropdown.querySelector('button').addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent document click from closing immediately
        toggleDropdown(captionsDropdownContent);
        // Close other dropdowns
        episodesDropdownContent.style.display = 'none';
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
        if (!episodesDropdown.contains(e.target)) {
            episodesDropdownContent.style.display = 'none';
        }
        if (!captionsDropdown.contains(e.target)) {
            captionsDropdownContent.style.display = 'none';
        }
    });

    // Event listeners for showing/hiding controls on mouse activity
    // Use mousemove on the player container to reset the timeout
    videoPlayer.addEventListener('mousemove', showControls);
    // Add mouseleave to hide controls immediately if mouse leaves player area
    videoPlayer.addEventListener('mouseleave', hideControls);


    // Event listener for fullscreen change
    document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
            // Entered native fullscreen
            console.log("Event: Entered native fullscreen.");
            // No change to screenMode, as it's a separate state
            // Button text/icon will be updated by showControls if needed
            showControls();
        } else {
            // Exited native fullscreen
            console.log("Event: Exited native fullscreen.");
            // After exiting native fullscreen, set screenMode back to 'full' windowed
            screenMode = 'full';
            videoPlayer.classList.remove('mini-player'); // Ensure mini-player class is off
            document.body.style.overflow = 'hidden'; // Keep main page scrolling disabled if player is full windowed
            updateMiniPlayerButtonText(); // Reset button text
            updatePlayerControlButtons(false); // Restore full button text
            hideControls();
        }
    });

    // --- Cast & Crew Functions ---
    toggleCastCrewBtn.addEventListener('click', () => {
        console.log("toggleCastCrewBtn: Toggling cast crew section.");
        castCrewSection.classList.toggle('active');
        // If cast section opens, ensure player is not covered if in full screen mode
        if (castCrewSection.classList.contains('active') && screenMode === 'full') { // Use screenMode
            videoPlayer.style.width = `calc(100% - ${castCrewSection.offsetWidth}px)`;
            console.log("toggleCastCrewBtn: Player width adjusted for cast section.");
        } else if (screenMode === 'full') { // Use screenMode
            videoPlayer.style.width = '100%';
            console.log("toggleCastCrewBtn: Player width restored.");
        }
        // No need to call applyParentSettings here, as floating buttons are already hidden by player being active
    });

    closeCastCrewBtn.addEventListener('click', () => {
        console.log("closeCastCrewBtn: Closing cast crew section.");
        castCrewSection.classList.remove('active');
        // Restore player width if in full screen mode
        if (screenMode === 'full') { // Use screenMode
            videoPlayer.style.width = '100%';
            console.log("closeCastCrewBtn: Player width restored.");
        }
        // No need to call applyParentSettings here, as floating buttons are already hidden by player being active
    });

    /**
     * Loads and displays the cast and crew for the current content.
     * @param {object} contentDetails - The movie or series content details.
     */
    async function loadCastAndCrew(contentDetails) {
        console.log("loadCastAndCrew: Loading cast for content:", contentDetails);
        castListContainer.innerHTML = '<p class="text-gray-400 text-center">Loading cast...</p>';
        if (!contentDetails || !contentDetails.cast || contentDetails.cast.length === 0) {
            castListContainer.innerHTML = '<p class="text-gray-400 text-center">No cast information available.</p>';
            console.log("loadCastAndCrew: No cast info found.");
            return;
        }

        const castPromises = contentDetails.cast.map(async (actor) => {
            if (actor.tmdbId && TMDB_API_KEY !== 'your_tmdb_api_key_here') {
                try {
                    const response = await fetch(`${TMDB_BASE_URL}/person/${actor.tmdbId}?api_key=${TMDB_API_KEY}`);
                    const data = await response.json();
                    return {
                        name: data.name,
                        character: actor.character,
                        profile_path: data.profile_path,
                        id: data.id // TMDB person ID
                    };
                } catch (error) {
                    console.error(`loadCastAndCrew: Error fetching TMDB data for ${actor.name}:`, error);
                    return { name: actor.name, character: actor.character, profile_path: null, id: null };
                }
            } else {
                return { name: actor.name, character: actor.character, profile_path: null, id: null };
            }
        });

        const detailedCast = await Promise.all(castPromises);
        castListContainer.innerHTML = ''; // Clear loading message
        console.log("loadCastAndCrew: Detailed cast fetched:", detailedCast);

        detailedCast.forEach(actor => {
            const castCard = document.createElement('div');
            castCard.classList.add('cast-card');
            if (actor.id) {
                castCard.onclick = () => showCastDetailsModal(actor.id);
            } else {
                castCard.style.cursor = 'default'; // No click if no TMDB ID
            }

            const profileImgSrc = actor.profile_path ? `${TMDB_PROFILE_SMALL_URL}${actor.profile_path}` : 'https://placehold.co/60x60?text=N/A';

            castCard.innerHTML = `
                <img src="${profileImgSrc}" alt="${actor.name}"/>
                <div class="cast-info">
                    <h4>${actor.name}</h4>
                    <p>${actor.character || 'N/A'}</p>
                </div>
            `;
            castListContainer.appendChild(castCard);
        });
        console.log("loadCastAndCrew: Cast cards appended to list. Total children:", castListContainer.children.length);
    }

    /**
     * Shows a modal with detailed information about a cast member.
     * @param {number} personId - The TMDB person ID.
     */
    async function showCastDetailsModal(personId) {
        console.log("showCastDetailsModal: Opening modal for personId:", personId);
        if (TMDB_API_KEY === 'your_tmdb_api_key_here') { // Check for placeholder key
            showTempAuthMessage('Please replace "your_tmdb_api_key_here" with your actual TMDB API key to fetch cast details.', 'orange');
            return;
        }
        // Close other modals that might be open
        closeAllModalsExcept('castDetailModal');

        castDetailModal.style.display = 'flex';
        castDetailName.textContent = 'Loading...';
        castDetailBio.textContent = '';
        castDetailImage.src = 'https://placehold.co/120x120?text=Loading...';
        knownForGrid.innerHTML = '';

        try {
            // Fetch person details
            const personRes = await fetch(`${TMDB_BASE_URL}/person/${personId}?api_key=${TMDB_API_KEY}`);
            const personData = await personRes.json();
            console.log("showCastDetailsModal: Person data:", personData);

            castDetailName.textContent = personData.name || 'N/A';
            castDetailBio.textContent = personData.biography || 'No biography available.';
            castDetailImage.src = personData.profile_path ? `${TMDB_IMAGE_BASE_URL}${personData.profile_path}` : 'https://placehold.co/120x120?text=No+Image';

            // Fetch combined credits (movies and TV shows)
            const creditsRes = await fetch(`${TMDB_BASE_URL}/person/${personId}/combined_credits?api_key=${TMDB_API_KEY}`);
            const creditsData = await creditsRes.json();
            console.log("showCastDetailsModal: Credits data:", creditsData);

            const knownFor = creditsData.cast
                .sort((a, b) => b.popularity - a.popularity) // Sort by popularity
                .slice(0, 8); // Get top 8 "known for" titles

            if (knownFor.length > 0) {
                knownFor.forEach(item => {
                    const card = document.createElement('div');
                    card.classList.add('known-for-card');
                    const posterPath = item.poster_path ? `${TMDB_IMAGE_BASE_URL}${item.poster_path}` : 'https://placehold.co/120x180?text=No+Poster';
                    const title = item.media_type === 'movie' ? item.title : item.name;
                    card.innerHTML = `
                        <img src="${posterPath}" alt="${title}"/>
                        <h4>${title || 'N/A'}</h4>
                    `;
                    knownForGrid.appendChild(card);
                });
                console.log("showCastDetailsModal: Known for titles rendered.");
            } else {
                knownForGrid.innerHTML = '<p class="text-gray-400 text-center col-span-full">No known for titles available.</p>';
                console.log("showCastDetailsModal: No known for titles found.");
            }
        } catch (error) {
            console.error("showCastDetailsModal: Error fetching cast details:", error);
            castDetailName.textContent = 'Error';
            castDetailBio.textContent = 'Failed to load details.';
            castDetailImage.src = 'https://placehold.co/120x120?text=Error';
            knownForGrid.innerHTML = '<p class="text-red-400 text-center col-span-full">Failed to load known for titles.</p>';
        }
    }

    function closeCastDetailsModal() {
        console.log("closeCastDetailsModal: Closing cast details modal.");
        castDetailModal.style.display = 'none';
        applyParentSettings(); // Re-evaluate floating button visibility
    }


    // Hero Slideshow Functions and Content
    const featuredContent = [
        {
            id: 'galactic-explorer', // Added ID
            title: "The Galactic Explorer",
            description: "An epic journey across unknown galaxies to discover ancient civilizations.",
            poster: "https://placehold.co/1500x600?text=Galactic+Explorer+Poster",
            video: "https://www.w3schools.com/html/mov_bbb.mp4",
            trailer: "https://www.w3schools.com/html/mov_bbb.mp4", // Placeholder for trailer
            type: 'movie',
            genre: 'Sci-Fi', // Added genre
            year: '2025', // Added year
            // Added structured cast with TMDB IDs (example IDs, replace with real ones if needed)
            cast: [
                { name: 'Tom Hanks', character: 'Captain John', tmdbId: 31 },
                { name: 'Scarlett Johansson', character: 'Dr. Lena', tmdbId: 1245 },
                { name: 'Morgan Freeman', character: 'Narrator', tmdbId: 192 }
            ],
            director: 'Alice Wonderland', // Added director
            rating: 'PG' // Added rating
        },
        {
            id: 'forgotten-city', // Added ID
            title: "Mystery of the Forgotten City",
            description: "A thrilling adventure deep into the jungle to uncover a lost city's secrets.",
            poster: "https://placehold.co/1500x600?text=Forgotten+City+Poster",
            video: "https://www.w3schools.com/html/mov_bbb.mp4",
            trailer: "https://www.w3schools.com/html/mov_bbb.mp4", // Placeholder for trailer
            type: 'movie',
            genre: 'Adventure', // Added genre
            year: '2024', // Added year
            cast: [
                { name: 'Dwayne Johnson', character: 'Dr. Brave', tmdbId: 18918 },
                { name: 'Emily Blunt', character: 'Lily Houghton', tmdbId: 10205 }
            ],
            director: 'David Green', // Added director
            rating: 'PG-13' // Added rating
        },
        {
            id: 'whispers-wind', // Added ID
            title: "Whispers of the Wind",
            description: "A heartwarming drama about friendship, loss, and finding hope.",
            poster: "https://placehold.co/1500x600?text=Whispers+Wind+Poster",
            video: "https://www.w3schools.com/html/mov_bbb.mp4",
            trailer: "https://www.w3schools.com/html/mov_bbb.mp4", // Placeholder for trailer
            type: 'movie',
            genre: 'Drama', // Added genre
            year: '2023', // Added year
            cast: [
                { name: 'Meryl Streep', character: 'Eleanor', tmdbId: 183 },
                { name: 'TimothÃ©e Chalamet', character: 'Daniel', tmdbId: 1190479 }
            ],
            director: 'Grace Red', // Added director
            rating: 'G' // Added rating
        },
        {
            id: 'eldoria-series-hero', // Added ID (distinct from eldoria-series in allMovies)
            title: "The Chronicles of Eldoria (Series)",
            description: "An epic fantasy series spanning multiple seasons.",
            poster: "https://placehold.co/1500x600?text=Eldoria+Series+Hero",
            type: 'series',
            seriesId: 'eldoria',
            genre: 'Fantasy', // Added genre
            year: '2023', // Added year
            cast: [ // Example cast for a series
                { name: 'Henry Cavill', character: 'Geralt', tmdbId: 94870 },
                { name: 'Anya Chalotra', character: 'Yennefer', tmdbId: 2133031 }
            ],
            director: 'Hero Director', // Added director
            rating: 'PG' // Added rating
        }
    ];

    let currentSlideIndex = 0;
    const heroSlideshowContainer = document.getElementById('hero-slideshow');

    function renderHeroSlides() {
        heroSlideshowContainer.innerHTML = ''; // Clear existing slides
        featuredContent.forEach((item, index) => {
            const slide = document.createElement('div');
            slide.classList.add('hero-slide');
            // Set CSS variable for background image
            slide.style.setProperty('--image-url', `url('${item.poster}')`);

            let buttonHtml = '';
            if (item.type === 'movie') {
                buttonHtml = `<button class="btn" onclick="openPlayer('${item.video}', '${item.title}', 'movie', ${JSON.stringify(item).replace(/"/g, '&quot;')}, 'full')">Watch Now</button>`; // Pass 'full' mode
            } else if (item.type === 'series') {
                buttonHtml = `<button class="btn" onclick="openPlayer(null, '${item.title}', 'series', ${JSON.stringify(item).replace(/"/g, '&quot;')}, 'full')">Watch Series</button>`; // Pass 'full' mode
            }

            slide.innerHTML = `
                <div class="hero-content-wrapper">
                    <h1>${item.title}</h1>
                    <p>${item.description}</p>
                    ${buttonHtml}
                </div>
            `;
            heroSlideshowContainer.appendChild(slide);
        });
        showSlide(currentSlideIndex);
    }

    function showSlide(index) {
        const slides = document.querySelectorAll('.hero-slide');
        if (slides.length === 0) return;

        slides.forEach((slide, i) => {
            slide.classList.remove('active');
            if (i === index) {
                slide.classList.add('active');
            }
        });
    }

    function nextSlide() {
        currentSlideIndex = (currentSlideIndex + 1) % featuredContent.length;
        showSlide(currentSlideIndex);
    }

    // Start slideshow
    setInterval(nextSlide, 5000); // Change slide every 5 seconds

    // Dynamic Content Loading and Event Listeners
    let allMovies = []; // Store all movies for searching and filtering

    document.addEventListener('DOMContentLoaded', () => {
        renderHeroSlides(); // Initialize hero slideshow
        loadLatestReleases(); // This also populates `allMovies`
        loadLiveChannels();
        loadCategories();
        applyParentSettings(); // Apply parent control settings on page load
        checkMembershipStatus(); // Check and update UI for membership status

        // Ensure lumaPanel is hidden on page load
        lumaPanel.style.display = 'none';
        lumaPanel.style.right = '0px'; // Reset position
        // Ensure chatBox is hidden on page load
        chatBox.style.display = 'none';
        chatBox.style.right = '0px'; // Reset position


        // Event listener for movie search
        document.getElementById('movieSearchInput').addEventListener('input', filterMovies);
        document.getElementById('memberSignUpLink').addEventListener('click', (e) => {
            e.preventDefault();
            openAuthModal('login'); // Changed to open in 'login' mode by default
        });
        document.getElementById('memberLogoutLink').addEventListener('click', (e) => {
            e.preventDefault();
            logout();
        });
        document.getElementById('myFavoritesLink').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('contentSectionTitle').textContent = 'My Favorites';
            displayFavorites();
        });
        document.getElementById('homeLink').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('contentSectionTitle').textContent = 'Latest Releases';
            displayMovies(allMovies); // Show all movies again
        });
        document.getElementById('moviesLink').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('contentSectionTitle').textContent = 'All Movies';
            displayMovies(allMovies.filter(item => item.type === 'movie'));
        });
        document.getElementById('tvShowsLink').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('contentSectionTitle').textContent = 'TV Series';
            displayMovies(allMovies.filter(item => item.type === 'series'));
        });


        // Add event listener for password toggle after DOM is loaded
        const toggleAuthPassword = document.getElementById('toggleAuthPassword');
        if (toggleAuthPassword) {
            toggleAuthPassword.addEventListener('click', function (e) {
                const passwordInput = document.getElementById('authPassword');
                // Toggle the type attribute
                const type = passwordInput.getAttribute('type') === 'password' ? 'text' : 'password';
                passwordInput.setAttribute('type', type);
                // Toggle the eye icon
                this.classList.toggle('fa-eye');
                this.classList.toggle('fa-eye-slash');
            });
        }

        // Event listeners for floating buttons
        chatToggleButtonFloating.addEventListener('click', openChat);
        lumaToggleBtnFloating.addEventListener('click', toggleLumaPanel);
    });

    function loadLatestReleases() {
        const grid = document.getElementById('latest-releases-grid');
        grid.innerHTML = ''; // Clear existing content
        allMovies = [ // Updated with trailer URLs and more diverse content
            { id: 'advquest', title: "Adventure Quest", genre: "Adventure", year: "2023", poster: "https://placehold.co/200x300?text=Adventure+Quest", rating: "PG", video: "https://www.w3schools.com/html/mov_bbb.mp4", trailer: "https://www.w3schools.com/html/mov_bbb.mp4", type: 'movie', description: 'A thrilling adventure.', cast: [{ name: 'Chris Pratt', character: 'Hero', tmdbId: 73457 }, { name: 'Zoe Saldana', character: 'Warrior', tmdbId: 5465 }] },
            { id: 'cosjourney', title: "Cosmic Journey", genre: "Sci-Fi", year: "2024", poster: "https://placehold.co/200x300?text=Cosmic+Journey", rating: "PG-13", video: "https://www.w3schools.com/html/mov_bbb.mp4", trailer: "https://www.w3schools.com/html/mov_bbb.mp4", type: 'movie', description: 'An interstellar voyage.', cast: [{ name: 'TimothÃ©e Chalamet', character: 'Pilot', tmdbId: 1190479 }, { name: 'Zendaya', character: 'Navigator', tmdbId: 550153 }] },
            { id: 'darksecret', title: "The Darkest Secret", genre: "Thriller", year: "2023", poster: "https://placehold.co/200x300?text=Darkest+Secret", rating: "R", video: "https://www.w3schools.com/html/mov_bbb.mp4", trailer: "https://www.w3schools.com/html/mov_bbb.mp4", type: 'movie', description: 'A suspenseful thriller.', cast: [{ name: 'Leonardo DiCaprio', character: 'Detective', tmdbId: 6193 }, { name: 'Margot Robbie', character: 'Suspect', tmdbId: 234352 }] },
            { id: 'lovesecho', title: "Love's Echo", genre: "Romance", year: "2024", poster: "https://placehold.co/200x300?text=Loves+Echo", rating: "G", video: "https://www.w3schools.com/html/mov_bbb.mp4", trailer: "https://www.w3schools.com/html/mov_bbb.mp4", type: 'movie', description: 'A heartwarming romance.', cast: [{ name: 'Ryan Gosling', character: 'Lead Male', tmdbId: 500 }, { name: 'Emma Stone', character: 'Lead Female', tmdbId: 109966 }] },
            { id: 'horrornight', title: "Horror Night", genre: "Horror", year: "2023", poster: "https://placehold.co/200x300?text=Horror+Night", rating: "R", video: "https://www.w3schools.com/html/mov_bbb.mp4", trailer: "https://www.w3schools.com/html/mov_bbb.mp4", type: 'movie', description: 'A terrifying horror film.', cast: [{ name: 'Jamie Lee Curtis', character: 'Survivor', tmdbId: 1807 }, { name: 'Patrick Wilson', character: 'Paranormal Investigator', tmdbId: 17604 }] },
            { id: 'spaceody', title: "Space Odyssey", genre: "Sci-Fi", year: "2001", poster: "https://placehold.co/200x300?text=Space+Odyssey", rating: "G", video: "https://www.w3schools.com/html/mov_bbb.mp4", trailer: "https://www.w3schools.com/html/mov_bbb.mp4", type: 'movie', description: 'A classic sci-fi.', cast: [{ name: 'Keir Dullea', character: 'Dr. Dave Bowman', tmdbId: 10472 }, { name: 'Gary Lockwood', character: 'Dr. Frank Poole', tmdbId: 30128 }] },
            { id: 'comedyshow', title: "The Comedy Show", genre: "Comedy", year: "2022", poster: "https://placehold.co/200x300?text=Comedy+Show", rating: "PG", video: "https://www.w3schools.com/html/mov_bbb.mp4", trailer: "https://www.w3schools.com/html/mov_bbb.mp4", type: 'movie', description: 'A hilarious comedy.', cast: [{ name: 'Adam Sandler', character: 'Comedian', tmdbId: 19567 }, { name: 'Drew Barrymore', character: 'Love Interest', tmdbId: 1620 }] },
            // Re-linked the correct test series video here
            { id: 'eldoria-series', title: "The Chronicles of Eldoria", genre: "Fantasy", year: "2023", poster: "https://placehold.co/200x300?text=Eldoria+Series", rating: "PG", type: 'series', seriesId: 'eldoria', description: 'An epic fantasy series.', cast: [{ name: 'Henry Cavill', character: 'Geralt', tmdbId: 94870 }, { name: 'Anya Chalotra', character: 'Yennefer', tmdbId: 2133031 }],
              seasons: [ // Full season data for series playback
                {
                    seasonNumber: 1,
                    episodes: [
                        { id: "s1e1", title: "A New Beginning", videoUrl: "https://www.w3schools.com/html/mov_bbb.mp4", captions: [{ lang: "en", label: "English", src: "data:text/vtt;base64," + btoa("WEBVTT\\n\\n1\\n00:00:01.000 --> 00:00:04.000\\nHello, and welcome to Eldoria.\\n\\n2\\n00:00:05.000 --> 00:00:08.000\\nThis is the first episode.") }] }
                    ]
                },
                {
                    seasonNumber: 2,
                    episodes: [
                        { id: "s2e1", title: "Return to the Kingdom", videoUrl: "https://www.w3schools.com/html/mov_bbb.mp4", captions: [{ lang: "en", label: "English", src: "data:text/vtt;base64," + btoa("WEBVTT\\n\\n1\\n00:00:01.000 --> 00:00:04.000\\nWe are back home.\\n\\n2\\n00:00:05.000 --> 00:00:08.000\\nThe kingdom awaits.") }] }
                    ]
                }
              ]
            }
        ];

        displayMovies(allMovies);
    }

    function displayMovies(moviesToDisplay) {
        const grid = document.getElementById('latest-releases-grid');
        grid.innerHTML = ''; // Clear current display
        const userFavorites = JSON.parse(localStorage.getItem('userFavorites') || '[]');

        moviesToDisplay.forEach(contentItem => { // Renamed 'movie' to 'contentItem' for clarity
            const movieCard = document.createElement('div');
            movieCard.classList.add('movie-card');
            movieCard.setAttribute('data-title', contentItem.title.toLowerCase());
            movieCard.setAttribute('data-genre', contentItem.genre.toLowerCase());
            movieCard.setAttribute('data-rating', contentItem.rating); // For parent control filtering
            movieCard.setAttribute('data-movie-id', contentItem.id); // For favorites

            // Add event listeners for hover and click
            movieCard.onmouseenter = () => playTrailerOnHover(movieCard, contentItem.trailer);
            movieCard.onmouseleave = () => stopTrailerOnHover(movieCard); // Corrected to use 'movieCard'

            // --- MODIFIED: Add click event to send data to parent (admin) ---
            movieCard.onclick = (e) => {
                // Prevent click on video element or favorite icon from triggering content selection for admin
                if (e.target.tagName === 'VIDEO' || e.target.classList.contains('favorite-icon')) {
                    return;
                }
                stopTrailerOnHover(movieCard); // Ensure trailer stops

                // Send content details to the parent (admin dashboard)
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'contentSelected',
                        content: {
                            id: contentItem.id,
                            title: contentItem.title,
                            description: contentItem.description,
                            video: contentItem.video,
                            poster: contentItem.poster,
                            genre: contentItem.genre,
                            year: contentItem.year,
                            cast: contentItem.cast || [], // Ensure cast array is passed
                            director: contentItem.director || '', // Ensure these are passed if available
                            rating: contentItem.rating,
                            type: contentItem.type,
                            seriesId: contentItem.type === 'series' ? contentItem.id : undefined, // Pass contentItem.id as seriesId
                            seasons: contentItem.type === 'series' ? contentItem.seasons : undefined // Pass seasons for series
                        }
                    }, window.location.origin); // Ensure origin is correct for security
                }

                // Also open the player as before
                if (contentItem.type === 'series') {
                    openPlayer(null, contentItem.title, 'series', { seriesId: contentItem.id, cast: contentItem.cast }, 'full'); // Pass 'full' mode
                } else { // Default to movie
                    openPlayer(contentItem.video, contentItem.title, 'movie', contentItem, 'full'); // Pass 'full' mode
                }
            };
            // --- END MODIFIED SECTION ---


            const isFavorited = userFavorites.includes(contentItem.id);
            movieCard.innerHTML = `
                <i class="fas fa-heart favorite-icon ${isFavorited ? 'favorited' : ''}" onclick="toggleFavorite(event, '${contentItem.id}')"></i>
                <img class="poster-image" src="${contentItem.poster}" alt="${contentItem.title}">
                <video class="trailer-preview" muted loop playsinline></video>
                <div class="movie-card-content">
                    <h3>${contentItem.title}</h3>
                    <p>${contentItem.genre} (${contentItem.year})</p>
                    <p>Rating: ${contentItem.rating}</p>
                </div>
                ${contentItem.type === 'series' ? '<span class="series-badge">Series</span>' : ''}
            `;
            grid.appendChild(movieCard);
        });
        filterContent(); // Apply parent control filters after loading and displaying
    }

    function playTrailerOnHover(card, trailerUrl) {
        const img = card.querySelector('.poster-image');
        const video = card.querySelector('.trailer-preview');
        if (trailerUrl) {
            video.src = trailerUrl;
            video.play().then(() => {
                img.style.display = 'none';
                video.style.display = 'block';
            }).catch(error => {
                console.warn("Autoplay prevented or no trailer:", error);
                // Fallback to just showing poster if autoplay fails
                img.style.display = 'block';
                video.style.display = 'none';
            });
        }
    }

    function stopTrailerOnHover(card) {
        const img = card.querySelector('.poster-image');
        const video = card.querySelector('.trailer-preview');
        video.pause();
        video.currentTime = 0; // Reset video to start
        video.style.display = 'none';
        img.style.display = 'block';
    }


    function loadLiveChannels() {
        const grid = document.getElementById('live-channels-grid');
        grid.innerHTML = '';
        const channels = [
            { name: "FLM News", img: "https://placehold.co/200x150?text=FLM+News", status: "Live", video: "https://www.w3schools.com/html/mov_bbb.mp4" },
            { name: "Comedy Central", img: "https://placehold.co/200x150?text=Comedy+Central", status: "24/7", video: "https://www.w3schools.com/html/mov_bbb.mp4" },
            { name: "Sports Arena", img: "https://placehold.co/200x150?text=Sports+Arena", status: "Live", video: "https://www.w3schools.com/html/mov_bbb.mp4" },
            { name: "Kids Zone", img: "https://placehold.co/200x150?text=Kids+Zone", status: "24/7", video: "https://www.w3schools.com/html/mov_bbb.mp4" },
            { name: "Documentary Hub", img: "https://placehold.co/200x150?text=Documentary+Hub", status: "Live", video: "https://www.w3schools.com/html/mov_bbb.mp4" },
            { name: "Music Mania", img: "https://placehold.co/200x150?text=Music+Mania", status: "24/7", video: "https://www.w3schools.com/html/mov_bbb.mp4" },
            { name: "Cooking Channel", img: "https://placehold.co/200x150?text=Cooking+Channel", status: "Live", video: "https://www.w3schools.com/html/mov_bbb.com/html/mov_bbb.mp4" },
            { name: "Travel & Explore", img: "https://placehold.co/200x150?text=Travel+Explore", status: "24/7", video: "https://www.w3schools.com/html/mov_bbb.mp4" }
        ];

        channels.forEach(channel => {
            const channelCard = document.createElement('div');
            channelCard.classList.add('channel-card');
            channelCard.onclick = () => openPlayer(channel.video, channel.name, 'movie', channel, 'full'); // Pass 'full' mode
            channelCard.innerHTML = `
                <img src="${channel.img}" alt="${channel.name}">
                <div class="channel-card-content">
                    <h3>${channel.name}</h3>
                    <p>${channel.status}</p>
                </div>
            `;
            grid.appendChild(channelCard);
        });
    }

    function loadCategories() {
        const grid = document.getElementById('browse-categories-grid');
        grid.innerHTML = '';
        const categories = [
            { name: "Action", icon: "fas fa-bomb" },
            { name: "Comedy", icon: "fas fa-laugh" },
            { name: "Drama", icon: "fas fa-mask" },
            { name: "Sci-Fi", icon: "fas fa-rocket" },
            { name: "Horror", icon: "fas fa-ghost" },
            { name: "Family", icon: "fas fa-child" }
        ];

        categories.forEach(category => {
            const categoryCard = document.createElement('div');
            categoryCard.classList.add('category-card');
            categoryCard.setAttribute('data-category-name', category.name);
            categoryCard.innerHTML = `
                <i class="${category.icon}"></i>
                <h3>${category.name}</h3>
            `;
            grid.appendChild(categoryCard);
        });
        filterContent(); // Apply parent control filters after loading content
    }

    // Movie Search Functionality
    function filterMovies() {
        const searchTerm = document.getElementById('movieSearchInput').value.toLowerCase();
        const filteredMovies = allMovies.filter(movie => {
            return movie.title.toLowerCase().includes(searchTerm) ||
                   movie.genre.toLowerCase().includes(searchTerm);
        });
        document.getElementById('contentSectionTitle').textContent = 'Search Results';
        displayMovies(filteredMovies);
    }

    // Parent Control Functions
    const PARENT_PASSWORD = "adminpass"; // Hardcoded password for demonstration

    function openParentControlModal() {
        document.getElementById('parentControlModal').style.display = 'flex';
        document.getElementById('parentPassword').value = ''; // Clear password field
        document.getElementById('controlToggles').style.display = 'none'; // Hide toggles

        // Close other modals
        closeAllModalsExcept('parentControlModal');

        const storedCode = localStorage.getItem("parentCode");
        if (storedCode) {
            document.getElementById("parentPasswordSetup").style.display = "none";
            document.getElementById("parentPasswordEntry").style.display = "block";
            document.getElementById("parentControlModalTitle").textContent = "Enter Parent Code";
        } else {
            document.getElementById("parentPasswordSetup").style.display = "block";
            document.getElementById("parentPasswordEntry").style.display = "none";
            document.getElementById("parentPasswordSetupMessage").textContent = "Set up your 4-digit parent code and security question.";
            document.getElementById("parentControlModalTitle").textContent = "Set Parent Code";
        }

        document.getElementById("parentSecurityQuestionEntry").style.display = "none";
        document.getElementById("controlToggles").style.display = "none";
    }

    function closeParentControlModal() {
        document.getElementById("parentControlModal").style.display = 'none';
        applyParentSettings(); // Re-evaluate floating button visibility
    }

    function setParentCode() {
        const code = document.getElementById("newParentPassword").value;
        const confirm = document.getElementById("confirmParentPassword").value;
        const question = document.getElementById("securityQuestion").value;
        const answer = document.getElementById("securityAnswer").value;
        const msg = document.getElementById("parentPasswordSetupMessage");

        if (code.length !== 4 || isNaN(code) || code !== confirm) { // Added isNaN check
            msg.textContent = "Codes do not match or are not a 4-digit number.";
            msg.style.color = "red";
            return;
        }

        if (!question || !answer) {
            msg.textContent = "Please fill in the security question and answer.";
            msg.style.color = "red";
            return;
        }

        localStorage.setItem("parentCode", code);
        localStorage.setItem("parentQuestion", question);
        localStorage.setItem("parentAnswer", answer.toLowerCase());

        msg.textContent = "Parent code set successfully!";
        msg.style.color = "lightgreen";
        setTimeout(() => {
            closeParentControlModal();
            openParentControlModal(); // Re-open to show code entry
        }, 1500);
    }

    function checkParentCodeManually() {
        const storedCode = localStorage.getItem("parentCode");
        const input = document.getElementById("parentPassword").value;
        const msg = document.getElementById("parentPasswordSetupMessage"); // Assuming this can be used for general messages too

        if (input === storedCode) {
            document.getElementById("parentPasswordEntry").style.display = "none";
            document.getElementById("controlToggles").style.display = "block";
            loadParentSettings();
            msg.textContent = ""; // Clear message on success
        } else {
            msg.textContent = "Incorrect code.";
            msg.style.color = "red";
        }
    }

    function checkParentCode(event) {
        if (event.key === "Enter") {
            checkParentCodeManually();
        }
    }

    function promptForSecurityAnswer() {
        document.getElementById("parentPasswordSetup").style.display = "none";
        document.getElementById("parentPasswordEntry").style.display = "none";
        document.getElementById("parentSecurityQuestionEntry").style.display = "block";
        document.getElementById("displayedSecurityQuestion").innerText = localStorage.getItem("parentQuestion") || "No question set.";
    }

    function verifySecurityAnswer() {
        const userAnswer = document.getElementById("securityAnswerInput").value.toLowerCase();
        const correctAnswer = localStorage.getItem("parentAnswer");
        const msg = document.getElementById("parentPasswordSetupMessage"); // Using this for messages

        if (userAnswer === correctAnswer) {
            msg.textContent = "Answer correct. Please set a new code.";
            msg.style.color = "lightgreen";
            document.getElementById("newParentPassword").value = '';
            document.getElementById("confirmParentPassword").value = '';
            document.getElementById("securityAnswerInput").value = ''; // Clear previous answer
            document.getElementById("parentPasswordSetup").style.display = "block";
            document.getElementById("parentSecurityQuestionEntry").style.display = "none";
            document.getElementById("parentPasswordSetupMessage").textContent = "Enter your new 4-digit code.";
            document.getElementById("parentPasswordSetupMessage").style.color = "yellow";
        } else {
            msg.textContent = "Incorrect answer.";
            msg.style.color = "red";
        }
    }

    function showControlToggles() {
        document.getElementById("parentPasswordEntry").style.display = "none";
        document.getElementById("controlToggles").style.display = "block";
    }

    function saveParentSettings() {
        const hideChat = document.getElementById('toggleHideChat').checked;
        const hideHorror = document.getElementById('toggleHideHorror').checked;
        const blockLiveTV = document.getElementById('toggleBlockLiveTV').checked;

        const blockedRatings = [];
        if (document.getElementById('toggleBlockRatingG').checked) blockedRatings.push('G');
        if (document.getElementById('toggleBlockRatingPG').checked) blockedRatings.push('PG');
        if (document.getElementById('toggleBlockRatingPG13').checked) blockedRatings.push('PG-13');
        if (document.getElementById('toggleBlockRatingR').checked) blockedRatings.push('R');
        if (document.getElementById('toggleBlockRatingNC17').checked) blockedRatings.push('NC-17'); // Assuming NC-17/X maps to 'NC-17'

        localStorage.setItem('hideChat', hideChat);
        localStorage.setItem('hideHorror', hideHorror);
        localStorage.setItem('blockLiveTV', blockLiveTV);
        localStorage.setItem('blockedRatings', JSON.stringify(blockedRatings)); // Store as JSON string

        const msg = document.getElementById("parentPasswordSetupMessage");
        msg.textContent = "Parent Control Settings Saved!";
        msg.style.color = "lightgreen";

        applyParentSettings(); // Apply new settings immediately
        setTimeout(() => {
            closeParentControlModal();
            msg.textContent = ""; // Clear message after closing
        }, 1500);
    }

    function loadParentSettings() {
        document.getElementById('toggleHideChat').checked = localStorage.getItem('hideChat') === 'true';
        document.getElementById('toggleHideHorror').checked = localStorage.getItem('hideHorror') === 'true';
        document.getElementById('toggleBlockLiveTV').checked = localStorage.getItem('blockLiveTV') === 'true';

        const blockedRatings = JSON.parse(localStorage.getItem('blockedRatings') || '[]');
        document.getElementById('toggleBlockRatingG').checked = blockedRatings.includes('G');
        document.getElementById('toggleBlockRatingPG').checked = blockedRatings.includes('PG');
        document.getElementById('toggleBlockRatingPG13').checked = blockedRatings.includes('PG-13');
        document.getElementById('toggleBlockRatingR').checked = blockedRatings.includes('R');
        document.getElementById('toggleBlockRatingNC17').checked = blockedRatings.includes('NC-17');
    }

    function applyParentSettings() {
        const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        const hideChatByParent = localStorage.getItem('hideChat') === 'true';
        const parentCodeSet = localStorage.getItem("parentCode") !== null; // True if code exists
        const blockLiveTVEnabled = localStorage.getItem('blockLiveTV') === 'true';


        // Determine if any *blocking* modal/overlay is currently open (excluding player, chatbox, luma panel)
        const isBlockingModalOpen = document.getElementById('parentControlModal').style.display === 'flex' ||
                               document.getElementById('memberAuthModal').style.display === 'flex' ||
                               document.getElementById('castDetailModal').style.display === 'flex';

        console.log("applyParentSettings: isLoggedIn:", isLoggedIn);
        console.log("applyParentSettings: hideChatByParent:", hideChatByParent);
        console.log("applyParentSettings: parentCodeSet:", parentCodeSet);
        console.log("applyParentSettings: blockLiveTVEnabled:", blockLiveTVEnabled);
        console.log("applyParentSettings: isBlockingModalOpen:", isBlockingModalOpen);
        console.log("applyParentSettings: videoPlayer.style.display:", videoPlayer.style.display);
        console.log("applyParentSettings: chatBox.style.display:", chatBox.style.display);
        console.log("applyParentSettings: lumaPanel.style.display:", lumaPanel.style.display);


        // Control floating chat button (main page only)
        // Show if logged in, not hidden by parent, and no blocking modals/player are open
        if (videoPlayer.style.display === 'none' && isLoggedIn && !hideChatByParent && !isBlockingModalOpen) {
            chatToggleButtonFloating.style.opacity = '1';
            chatToggleButtonFloating.style.pointerEvents = 'auto';
            console.log("applyParentSettings: Showing floating chat button.");
        } else {
            chatToggleButtonFloating.style.opacity = '0';
            chatToggleButtonFloating.style.pointerEvents = 'none';
            console.log("applyParentSettings: Hiding floating chat button.");
        }

        // Control floating LUMA AI button (main page only, appears only if logged in)
        // Show if logged in, and no blocking modals/player are open
        if (videoPlayer.style.display === 'none' && isLoggedIn && !isBlockingModalOpen) {
            lumaToggleBtnFloating.style.opacity = '1';
            lumaToggleBtnFloating.style.pointerEvents = 'auto';
            console.log("applyParentSettings: Showing floating AI button.");
        } else {
            lumaToggleBtnFloating.style.opacity = '0';
            lumaToggleBtnFloating.style.pointerEvents = 'none';
            console.log("applyParentSettings: Hiding floating AI button.");
        }

        // --- IMPORTANT: Explicitly show all content before applying any filters ---
        document.querySelectorAll('.movie-card').forEach(card => {
            card.style.display = 'block';
        });
        document.querySelectorAll('.channel-card').forEach(card => { // Ensure channel cards are also reset
            card.style.display = 'block';
        });
        document.querySelectorAll('.category-card').forEach(card => {
            card.style.display = 'flex'; // Categories use flex
        });
        liveTvSection.style.display = 'block'; // Show Live TV section by default
        categoriesSection.style.display = 'block'; // Show Categories section by default


        // NOW apply filters ONLY if parent code is set
        if (parentCodeSet) {
            const blockedRatings = JSON.parse(localStorage.getItem('blockedRatings') || '[]');
            const hideHorrorEnabled = localStorage.getItem('hideHorror') === 'true';

            // Filter Movies by Rating and Genre
            document.querySelectorAll('.movie-card').forEach(card => {
                const title = card.getAttribute('data-title');
                const rating = card.getAttribute('data-rating');
                const genre = card.getAttribute('data-genre');
                let hide = false;

                if (blockedRatings.includes(rating)) {
                    hide = true;
                }
                if (hideHorrorEnabled && genre === 'horror') {
                    hide = true;
                }

                if (hide) {
                    card.style.display = 'none';
                } else {
                    // card.style.display is already 'block' from the reset above
                }
            });

            // Filter Categories
            document.querySelectorAll('.category-card').forEach(card => {
                const categoryName = card.getAttribute('data-category-name').toLowerCase();
                let hide = false;

                if (hideHorrorEnabled && categoryName === 'horror') {
                    hide = true;
                }

                if (hide) {
                    card.style.display = 'none';
                } else {
                    // card.style.display is already 'flex' from the reset above
                }
            });

            // Block Live TV Channels section
            if (blockLiveTVEnabled) {
                liveTvSection.style.display = 'none';
            }
        } else {
            // Parental Controls NOT active. All content should be visible by default (no filtering applied).
        }
    }

    function filterContent() {
        // This function is now mostly handled by applyParentSettings
        // Keeping it as a separate call for clarity, but it just calls applyParentSettings
        applyParentSettings();
    }


    /* Member Authentication Functions */
    // This function handles opening the authentication modal
    function openAuthModal(mode = 'login') {
        const modal = document.getElementById('memberAuthModal');
        const title = document.getElementById('authModalTitle');
        const submitBtn = document.getElementById('authSubmitBtn');
        const statusMsg = document.getElementById('memberStatusMessage');
        const upgradeBtn = document.getElementById('upgradePremiumBtn');
        const authModeToggleText = document.getElementById('authModeToggleText');
        const authModeToggleLink = document.getElementById('authModeToggleLink');
        const tempMsg = document.getElementById('tempAuthMessage'); // Get temp message element

        // Close other modals
        closeAllModalsExcept('memberAuthModal');

        // Clear input fields and status message
        document.getElementById('authEmail').value = '';
        document.getElementById('authPassword').value = '';
        statusMsg.textContent = '';
        tempMsg.textContent = ''; // Clear temp message
        tempMsg.style.display = 'none'; // Hide temp message

        // Show upgrade button by default
        upgradeBtn.style.display = 'block';

        // Set modal content based on mode
        if (mode === 'signup') {
            title.textContent = 'Sign Up for Free';
            submitBtn.textContent = 'Sign Up';
            submitBtn.onclick = () => performAuth('signup');
            authModeToggleText.textContent = 'Already a member?';
            authModeToggleLink.textContent = 'Log In';
            authModeToggleLink.onclick = (e) => { e.preventDefault(); toggleAuthMode('login'); };
        } else { // Default mode is 'login'
            title.textContent = 'Log In';
            submitBtn.textContent = 'Log In';
            submitBtn.onclick = () => performAuth('login');
            authModeToggleText.textContent = 'Not a member?';
            authModeToggleLink.textContent = 'Sign Up';
            authModeToggleLink.onclick = (e) => { e.preventDefault(); toggleAuthMode('signup'); };
        }

        // Display the modal
        modal.style.display = 'flex';
    }

    // This function closes the authentication modal
    function closeAuthModal() {
        document.getElementById('memberAuthModal').style.display = 'none';
        document.getElementById('tempAuthMessage').textContent = ''; // Clear temp message on close
        document.getElementById('tempAuthMessage').style.display = 'none'; // Hide temp message on close
        applyParentSettings(); // Re-evaluate floating button visibility
    }

    // New function to toggle between login and signup within the modal
    function toggleAuthMode(newMode) {
        openAuthModal(newMode); // Re-use openAuthModal to set up the new mode
    }

    // This function is called when the "Sign Up" link inside the modal is clicked
    function showSignUp() {
        toggleAuthMode('signup'); // Use the new toggle function
    }

    // This function simulates the authentication process (login or signup)
    function performAuth(mode) {
        const email = document.getElementById('authEmail').value;
        const pass = document.getElementById('authPassword').value;
        const msg = document.getElementById('memberStatusMessage');

        if (!email || !pass) {
            msg.textContent = 'Please enter both email and password.';
            msg.style.color = 'orange';
            return;
        }
        // Simulate authentication success for any input
        localStorage.setItem('userEmail', email);
        localStorage.setItem('isLoggedIn', 'true');
        localStorage.setItem('isSubscriber', 'true'); // Mock behavior

        msg.textContent = `â ${mode === 'signup' ? 'Signed up' : 'Logged in'} successfully (mock)!`;
        msg.style.color = 'lightgreen';

        // Close modal after a short delay
        setTimeout(() => {
            closeAuthModal();
            checkMembershipStatus(); // Update UI after authentication
        }, 1500);
    }

    // This function handles user logout
    function logout() {
        localStorage.removeItem('userEmail');
        localStorage.removeItem('isLoggedIn');
        localStorage.removeItem('isSubscriber');
        localStorage.removeItem('userFavorites'); // Clear favorites on logout
        // Replaced alert with console.log, as per instructions.
        console.log("You have been logged out.");
        updateAuthUI(); // Update UI after logout
        applyParentSettings(); // Re-apply content filtering
    }

    // This function checks the membership status on page load and updates UI
    function checkMembershipStatus() {
        updateAuthUI(); // This will set the header chat button correctly on load
        applyParentSettings(); // Keep this to ensure content filtering is applied on load.
    }

    // This function updates the visibility of header links (Sign In/Sign Up, Logout, My Favorites)
    function updateAuthUI() {
        const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        const memberSignUpLink = document.getElementById('memberSignUpLink');
        const memberLogoutLink = document.getElementById('memberLogoutLink');
        const myFavoritesLink = document.getElementById('myFavoritesLink');
        // const headerChatToggleBtn = document.getElementById('headerChatToggleBtn'); // REMOVED AS PER USER REQUEST

        if (isLoggedIn) {
            memberSignUpLink.style.display = 'none';
            memberLogoutLink.style.display = 'inline-block';
            myFavoritesLink.style.display = 'inline-block';
            // headerChatToggleBtn.style.display = 'inline-block'; // REMOVED AS PER USER REQUEST
        } else {
            memberSignUpLink.style.display = 'inline-block';
            memberLogoutLink.style.display = 'none';
            myFavoritesLink.style.display = 'none';
            // headerChatToggleBtn.style.display = 'none'; // REMOVED AS PER USER REQUEST
        }
    }

    // This function simulates password reset
    function handleForgotPassword() {
      const email = document.getElementById('authEmail').value;
      const msg = document.getElementById('memberStatusMessage');
      if (!email) {
        msg.textContent = "Please enter your email address above so we can send the reset link.";
        msg.style.color = 'orange';
        return;
      }
      msg.textContent = `A password reset link has-been sent to ${email} (simulated).`;
      msg.style.color = 'lightgreen';
    }

    // --- Favorites Logic ---
    function toggleFavorite(event, movieId) {
        event.stopPropagation(); // Prevent card click from opening player
        let userFavorites = JSON.parse(localStorage.getItem('userFavorites') || '[]');
        const icon = event.target;

        if (userFavorites.includes(movieId)) {
            userFavorites = userFavorites.filter(id => id !== movieId);
            icon.classList.remove('favorited');
        } else {
            userFavorites.push(movieId);
            icon.classList.add('favorited');
        }
        localStorage.setItem('userFavorites', JSON.stringify(userFavorites));
    }

    function displayFavorites() {
        const userFavorites = JSON.parse(localStorage.getItem('userFavorites') || '[]');
        const favoriteMovies = allMovies.filter(movie => userFavorites.includes(movie.id));

        document.getElementById('contentSectionTitle').textContent = 'My Favorites';
        displayMovies(favoriteMovies);
    }

    /**
     * Displays a temporary message within the authentication modal.
     * Used for non-critical alerts like "Please log in".
     * @param {string} message - The message to display.
     * @param {string} color - The color of the message (e.g., 'red', 'orange', 'lightgreen').
     */
    function showTempAuthMessage(message, color = 'orange') {
        const tempMsg = document.getElementById('tempAuthMessage');
        tempMsg.textContent = message;
        tempMsg.style.color = color;
        tempMsg.style.display = 'block';
        // Hide after a few seconds
        setTimeout(() => {
            tempMsg.style.display = 'none';
            tempMsg.textContent = '';
        }, 3000); // Message disappears after 3 seconds
    }

    // Function to open/close chat from the main page floating button
    function openChat() {
        console.log("openChat: Chat button clicked.");
        const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        console.log("openChat: Is logged in?", isLoggedIn);

        if (!isLoggedIn) {
            openAuthModal('login'); // Open auth modal
            showTempAuthMessage("You must be logged in to use chat.", 'orange'); // Show message in auth modal
            console.log("openChat: Not logged in, chat not opened. Auth modal shown.");
            return;
        }

        // Close other modals (but not lumaPanel, as they can be open together)
        closeAllModalsExcept('chatBox'); // This will close everything EXCEPT chatBox

        // Toggle chat box visibility
        if (chatBox.style.display === "none" || chatBox.style.display === "") {
            chatBox.style.display = "block";
            document.body.classList.add('chat-active'); // Add class to body when chat is open
            console.log("openChat: Chat box opened.");

            // Adjust panel positions and player
            if (lumaPanel.style.display === 'flex') { // If lumaPanel is already open
                chatBox.style.right = '0px'; // Chat is on the far right
                lumaPanel.style.right = '380px'; // Luma is to its left
            } else {
                chatBox.style.right = '0px'; // Chat is alone on the right
            }
            if (videoPlayer.style.display === 'flex') { // If video player is active
                adjustPlayerForPanel(); // Adjust player size
            }
        } else {
            chatBox.style.display = "none";
            document.body.classList.remove('chat-active'); // Remove class from body when chat is closed
            console.log("openChat: Chat box closed.");

            // Re-adjust panel positions and player
            if (lumaPanel.style.display === 'flex') { // If lumaPanel remains open
                lumaPanel.style.right = '0px'; // Move luma to the far right
            }
            adjustPlayerForPanel(); // Revert player size based on current panel state
        }
        applyParentSettings(); // Re-evaluate floating button visibility
    }

    // Function to close chat (added for the 'x' button)
    function closeChat() {
        console.log("closeChat: Closing chat box.");
        document.getElementById("chatBox").style.display = "none";
        document.body.classList.remove('chat-active'); // Ensure class is removed when chat is explicitly closed

        // Re-adjust panel positions and player
        if (lumaPanel.style.display === 'flex') { // If lumaPanel remains open
            lumaPanel.style.right = '0px'; // Move luma to the far right
        }
        adjustPlayerForPanel(); // Revert player size based on current panel state
        applyParentSettings(); // Re-evaluate floating button visibility
    }

    // NEW: Function to toggle chat from the video player button
    function toggleChatFromPlayer() {
        console.log("toggleChatFromPlayer: Chat button clicked from player controls.");
        const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        console.log("toggleChatFromPlayer: Is logged in?", isLoggedIn);

        if (!isLoggedIn) {
            openAuthModal('login'); // Open auth modal
            showTempAuthMessage("You must be logged in to use chat.", 'orange'); // Show message in auth modal
            console.log("toggleChatFromPlayer: Not logged in, chat not opened. Auth modal shown.");
            return;
        }
        // Close other modals (but not lumaPanel, as they can be open together)
        closeAllModalsExcept('chatBox');

        // Toggle chat box visibility
        if (chatBox.style.display === "none" || chatBox.style.display === "") {
            chatBox.style.display = "block";
            document.body.classList.add('chat-active');
            console.log("toggleChatFromPlayer: Chat box opened.");

            // Adjust panel positions and player
            if (lumaPanel.style.display === 'flex') { // If lumaPanel is already open
                chatBox.style.right = '0px'; // Chat is on the far right
                lumaPanel.style.right = '380px'; // Luma is to its left
            } else {
                chatBox.style.right = '0px'; // Chat is alone on the right
            }
            if (videoPlayer.style.display === 'flex') {
                adjustPlayerForPanel();
            }
        } else {
            chatBox.style.display = "none";
            document.body.classList.remove('chat-active');
            console.log("toggleChatFromPlayer: Chat box closed.");

            // Re-adjust panel positions and player
            if (lumaPanel.style.display === 'flex') { // If lumaPanel remains open
                lumaPanel.style.right = '0px'; // Move luma to the far right
            }
            adjustPlayerForPanel();
        }
        // No need to call applyParentSettings here, as floating buttons are already hidden by player being active
    }


    // Function to toggle AI panel
    function toggleLumaPanel() {
        console.log("toggleLumaPanel: AI button clicked.");
        const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
        console.log("toggleLumaPanel: Is logged in?", isLoggedIn);

        if (!isLoggedIn) {
            openAuthModal('login'); // Open auth modal
            showTempAuthMessage("You must be logged in to use AI.", 'orange'); // Show message in auth modal
            console.log("toggleLumaPanel: Not logged in, AI panel not opened. Auth modal shown.");
            return;
        }
        // Close other modals (but not chatBox, as they can be open together)
        closeAllModalsExcept('lumaPanel');

        // Toggle AI panel visibility
        if (lumaPanel.style.display === "none" || lumaPanel.style.display === "") {
            lumaPanel.style.display = "flex"; // Changed to flex for internal styling
            document.body.classList.add('luma-active'); // Add class to body when luma is open
            console.log("toggleLumaPanel: AI panel opened.");

            // Adjust panel positions and player
            if (chatBox.style.display === 'block') { // If chatBox is already open
                lumaPanel.style.right = '0px'; // Luma is on the far right
                chatBox.style.right = '380px'; // Chat is to its left
            } else {
                lumaPanel.style.right = '0px'; // Luma is alone on the right
            }
            if (videoPlayer.style.display === 'flex') { // If video player is active
                adjustPlayerForPanel();
            }
        } else {
            lumaPanel.style.display = "none";
            document.body.classList.remove('luma-active'); // Remove class from body when luma is closed
            console.log("toggleLumaPanel: AI panel closed.");

            // Re-adjust panel positions and player
            if (chatBox.style.display === 'block') { // If chatBox remains open
                chatBox.style.right = '0px'; // Move chat to the far right
            }
            adjustPlayerForPanel();
        }
        applyParentSettings(); // Re-evaluate floating button visibility
    }

    // Function to close AI panel (for its 'x' button)
    function closeLumaPanel() {
        console.log("closeLumaPanel: Closing AI panel.");
        document.getElementById("lumaPanel").style.display = "none";
        document.body.classList.remove('luma-active');

        // Re-adjust panel positions and player
        if (chatBox.style.display === 'block') { // If chatBox remains open
            chatBox.style.right = '0px'; // Move chat to the far right
        }
        adjustPlayerForPanel();
        applyParentSettings(); // Re-evaluate floating button visibility
    }

    /**
     * Closes all modal overlays except for the one specified by its ID.
     * This is a crucial helper to ensure only one overlay is active at a time.
     * @param {string} exceptId - The ID of the modal to keep open (e.g., 'chatBox', 'parentControlModal').
     */
    function closeAllModalsExcept(exceptId) {
        const modals = ['chatBox', 'parentControlModal', 'memberAuthModal', 'lumaPanel', 'castDetailModal'];
        modals.forEach(modalId => {
            // Only close modals that are NOT the one we want to keep open
            // and are NOT the video player (video player is handled separately)
            if (modalId !== exceptId && modalId !== 'videoPlayer') {
                const modalElement = document.getElementById(modalId);
                if (modalElement) {
                    modalElement.style.display = 'none';
                    // For panels that use classes for transitions, remove the active class
                    if (modalElement.classList.contains('active')) {
                        modalElement.classList.remove('active');
                    }
                    // Reset right position for panels when closed
                    if (modalId === 'chatBox' || modalId === 'lumaPanel') {
                        modalElement.style.right = '0px';
                    }
                }
            }
        });
        // Ensure body overflow is restored if no modals are open AND video player is not active
        // This logic might need slight adjustment if multiple panels are allowed to be open
        // For now, it restores if NO modals are open AND player is not active.
        const anyModalOrPanelOpen = modals.some(id => {
            const el = document.getElementById(id);
            return el && (el.style.display === 'block' || el.style.display === 'flex');
        });

        if (!anyModalOrPanelOpen && videoPlayer.style.display === 'none') {
            document.body.style.overflow = 'auto';
        }
    }


    // Debugging: Log CSS variables on load
    window.addEventListener('load', () => {
        const rootStyles = getComputedStyle(document.documentElement);
        console.log('CSS Variable --bg-light:', rootStyles.getPropertyValue('--bg-light'));
        console.log('CSS Variable --primary:', rootStyles.getPropertyValue('--primary'));
        console.log('CSS Variable --primary-dark:', rootStyles.getPropertyValue('--primary-dark'));
    });

</script>

<script>
// === Minimal Jellyfin data hook (no style changes) ===
const JF_SERVER = "http://192.168.132.50:8096";
const JF_API_KEY = "e91f6b3d38004f5cbe9f344ea19c2623";
const JF_USER_ID = "6396cd53259b4623bdf0ff4905bba497";

const $ = s => document.querySelector(s);
const imgUrl = (id, type="Primary", w=800) =>
  `${JF_SERVER}/Items/${id}/Images/${type}?maxWidth=${w}&api_key=${JF_API_KEY}`;
const hlsUrl = id => `${JF_SERVER}/Videos/${id}/main.m3u8?api_key=${JF_API_KEY}`;
const staticUrl = id => `${JF_SERVER}/Videos/${id}/stream?Static=true&api_key=${JF_API_KEY}`;
async function jf(path){ const r = await fetch(`${JF_SERVER}${path}${path.includes('?')?'&':'?'}api_key=${JF_API_KEY}`); return r.json(); }

async function playJF(item){
  const vp = $("#videoPlayer"), ve = $("#videoElement");
  if(!vp || !ve) return console.warn("Player elements not found");
  if(item.Type === "Series"){
    try{
      const up = await jf(`/Shows/NextUp?userId=${JF_USER_ID}&seriesId=${item.Id}&Limit=1`);
      if (up?.Items?.[0]) return playJF(up.Items[0]);
    }catch(e){}
  }
  const title = item.SeriesName ? `${item.SeriesName} â¢ ${item.Name}` : item.Name;
  $("#episodeTitle") && ($("#episodeTitle").textContent = title);
  $("#seriesInfo") && item.ProductionYear && ($("#seriesInfo").textContent = item.ProductionYear);
  const tryPlay = async src => { ve.src = src; $("#videoPlayer").style.display="block"; try { await ve.play(); return true; } catch { return false; } };
  if (!(await tryPlay(hlsUrl(item.Id)))) await tryPlay(staticUrl(item.Id));
}

function renderRow(container, items){
  container.innerHTML = "";
  items.forEach(it => {
    const card = document.createElement("div");
    card.className = "movie-card"; // use your existing card styling
    card.innerHTML = `
      <span class="favorite-icon fas fa-heart" style="display:none"></span>
      ${it.Type==='Series' ? '<span class="series-badge">Series</span>' : ''}
      <img src="${imgUrl(it.Id,'Primary',800)}" alt="${it.Name}"/>
      <div class="movie-card-content"><h3>${it.Name||""}</h3></div>`;
    card.addEventListener("click", () => playJF(it));
    container.appendChild(card);
  });
}

function setHero(it){
  const bg = $("#heroBg"); if(bg){ bg.style.backgroundImage = `url('${imgUrl(it.Id,'Backdrop',1600)}')`; bg.style.backgroundSize="cover"; bg.style.backgroundPosition="center"; }
  $("#heroTitle") && ($("#heroTitle").textContent = it.Name || "Featured");
  $("#heroOverview") && ($("#heroOverview").textContent = (it.Overview || "").slice(0,220));
  const btn = $("#heroPlayBtn"); if(btn){ btn.onclick = () => playJF(it); }
}

async function loadAll(){
  try{
    const views = await jf(`/Users/${JF_USER_ID}/Views`);
    const moviesView = views.Items?.find(v => /movie/i.test(v.Name||""))?.Id;
    const showsView  = views.Items?.find(v => /(tv|show|series)/i.test(v.Name||""))?.Id;

    const latest = await jf(`/Users/${JF_USER_ID}/Items/Latest?IncludeItemTypes=Movie,Series&Limit=24`);
    if(latest?.length){
      const lr = document.querySelector("#latestRow") || document.querySelector("#latest-releases-grid");
      if(lr) renderRow(lr, latest);
      setHero(latest[0]);
    }

    if(moviesView){
      const j = await jf(`/Users/${JF_USER_ID}/Items?ParentId=${moviesView}&IncludeItemTypes=Movie&SortBy=DateCreated&SortOrder=Descending&Limit=24`);
      const mr = document.querySelector("#moviesRow"); if(mr) renderRow(mr, j.Items || []);
    }
    if(showsView){
      const j = await jf(`/Users/${JF_USER_ID}/Items?ParentId=${showsView}&IncludeItemTypes=Series&SortBy=DateCreated&SortOrder=Descending&Limit=24`);
      const sr = document.querySelector("#showsRow"); if(sr) renderRow(sr, j.Items || []);
    }
  }catch(e){
    console.error(e);
    const el = document.querySelector("#latestRow") || document.querySelector("#latest-releases-grid");
    if(el) el.innerHTML = '<div style="color:#f88">Jellyfin load failed.</div>';
  }
}
loadAll();
</script>

</body>
</html>
<!-- THIS IS THE END OF THE COMPLETE INDEX.HTML FILE -->
